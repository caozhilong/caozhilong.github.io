---
layout:     post
title:      "ThreadLocal怎样工作的-上篇"
subtitle:   "JVM并发"
date:       2020-06-30 10:15:06
author:     "Ljee"
header-img: "img/economic/post-bg-how-economic-machines-work.jpg"
tags:
    - 并发
---


## 什么是ThreadLocal

先说说java内存模型，它主要是为了解决多线程下的共享内存操作问题，为了保证数据的一致性，我们在自己的工作内存操作修改变量后，会提交到主内存中进行覆盖，并且使其他线程中工作内存中的共享变量删除，使得其他线程在自己的工作内存中访问不到该共享变量副本，只能到主内存中去访问。这样就很好的保证了数据的可见性。但是，有时候我们希望在自己工作内存中修改共享变量副本后，不希望其他工作内存知道，即保持不可见性。那该怎么办呢，这是就要使用ThreadLocal了。

对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”又是从事最基础工作的“劳动人民”——既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。

对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图2-1所示。


## 设计思想

每个 `Thread` 维护维护一个 `ThreadLocalMap` 哈希表，这个哈希表的key 是
