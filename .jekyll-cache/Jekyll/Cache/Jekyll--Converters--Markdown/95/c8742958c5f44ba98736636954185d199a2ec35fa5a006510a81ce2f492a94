I"*<h1 id="java虚拟机metaspace">Java虚拟机：Metaspace</h1>

<p><strong>被废弃的持久代</strong></p>

<p>想起之前面试的时候有面试官问起过我一个问题：Java 8为什么要废弃持久代即Metaspace的作用。由于当时使用的Java 7且研究重心不在JVM上，一下没有回答上来，今天突然想起这个问题，就详细总结一下这个问题。</p>

<p>首先我们看一张JVM内存布局的图：</p>

<p><img src="https://images2018.cnblogs.com/blog/801753/201804/801753-20180401164846766-809607195.png" alt="" /></p>

<p>注意到里面有一块METHOD AREA，它是一块线程共享的对象，名为方法区，在HotSpot虚拟机中，这块METHOD AREA我们可以认为等同于持久代（PermGen），在Java 6及之前的版本，持久代存放了以下一些内容：</p>

<ul>
  <li>虚拟机加载的类信息</li>
  <li>常量池</li>
  <li>静态变量</li>
  <li>即时编译后的代码</li>
</ul>

<p>到了<strong>Java 7之后，常量池已经不在持久代之中进行分配了，而是移到了堆中</strong>，即常量池和对象共享堆内存。</p>

<p>接着到了Java 8之后的版本（至此篇文章，Java 10刚发布），持久代已经被永久移除，取而代之的是Metaspace。</p>

<p><strong>为什么要移除持久代</strong></p>

<p>HotSpot团队选择移除持久代，有内因和外因两部分，从外因来说，我们看一下<a href="http://openjdk.java.net/jeps/122">JEP 122</a>的Motivation（动机）部分：</p>

<pre>
This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.
</pre>

<p>这是JRockit和Hotspot融合工作的一部分。JRockit客户不需要配置永久代（因为JRockit没有永久代）并且习惯于不配置永久代。</p>

<p>将Hotspot中永久代的部分内容移动到Java堆，将剩余部分的内容移动到本机内存。</p>

<p>Hotspot对Java类的表示（此处称为类元数据）当前存储在Java堆的一部分中，称为永久生成。此外，实体化的字符串和类静态变量存储在永久代中。永久代由Hotspot管理，并且必须有足够的空间容纳所有类元数据，Java应用程序使用的内部字符串和类静态。类加载类时，在永久代中分配类元数据和静态，并在卸载类时从永久代收集垃圾。当永久代生成GC时，Interned Strings也会被垃圾收集。</p>

<p>建议的实现将在本机内存中分配类元数据，并将实际的字符串和类静态移动到Java堆。Hotspot将为类元数据显式分配和释放本机内存。新类元数据的分配将受可用本机内存量的限制，而不是由-XX：MaxPermSize的值固定，无论是默认值还是在命令行上指定。</p>

<p>用于类元数据的本机存储器的分配将以足够大的块来完成，以适合多个类元数据。每个块都将与一个类加载器相关联，并且该类加载器加载的所有类元数据将由Hotspot从该类加载器的块中分配。根据需要，将为类加载器分配附加块。块大小将根据应用程序的行为而变化。将选择尺寸以限制内部和外部碎片。当类加载器通过释放与类加载器相关联的所有块而死亡时，将释放类元数据的空间。类的元数据在课程期间不会被移动。</p>

<p>从内因来说，持久代大小受到-XX：PermSize和-XX：MaxPermSize两个参数的限制，而这两个参数又受到JVM设定的内存大小限制，这就导致<strong>在使用中可能会出现持久代内存溢出的问题</strong>，因此在Java 8及之后的版本中彻底移除了持久代而使用Metaspace来进行替代。</p>

<p><strong>Metaspace</strong></p>

<blockquote>
  <p>上面说了，为了避免出现持久代内存溢出的问题; 并且可以支持不同应用程序之间进行类共享而减少内存开销(可能会降低性能)，，Java 8及之后的版本彻底移除了持久代而使用Metaspace来进行替代。</p>
</blockquote>

<p>Metaspace是方法区在HotSpot中的实现，它与持久代最大的区别在于：<strong>Metaspace并不在虚拟机内存中而是使用本地内存</strong>。因此Metaspace具体大小理论上取决于32位/64位系统可用内存的大小，可见也不是无限制的，需要配置参数。</p>

<p>接着我们模拟一下Metaspace内存溢出的情况，前面说了持久代存放了以下信息：</p>

<ul>
  <li>虚拟机加载的类信息(类元数据)</li>
  <li>实体化的字符串</li>
  <li>静态类变量</li>
  <li>常量池</li>
  <li>即时编译后的代码</li>
</ul>

<p>所以最简单的模拟Metaspace内存溢出，我们只需要无限生成类信息即可，类占据的空间总是会超过Metaspace指定的空间大小的，下面用Cglib来模拟：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MetaspaceOOMTest</span> <span class="o">{</span>

    <span class="cm">/**
     * JVM参数:-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=128m -XX:+PrintFlagsInitial
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
                
                <span class="nc">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Enhancer</span><span class="o">();</span>
                <span class="n">enhancer</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="nc">OOMObject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                <span class="n">enhancer</span><span class="o">.</span><span class="na">setUseCache</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                <span class="n">enhancer</span><span class="o">.</span><span class="na">setCallback</span><span class="o">(</span><span class="k">new</span> <span class="nc">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
                    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">intercept</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="nc">MethodProxy</span> <span class="n">proxy</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="n">proxy</span><span class="o">.</span><span class="na">invokeSuper</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">});</span>
                <span class="n">enhancer</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"第"</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">"次时发生异常"</span><span class="o">);</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">OOMObject</span> <span class="o">{</span>
        
    <span class="o">}</span>
    
<span class="o">}</span>
</code></pre></div></div>
<p>虚拟机参数设置为”-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=128m”，运行代码，结果为：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>第15562次时发生异常
net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;null
    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:345)
    at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)
    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:114)
    at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291)
    at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)
    at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)
    at org.xrq.commom.test.jvm.MetaspaceOOMTest.main(MetaspaceOOMTest.java:34)
Caused by: java.lang.reflect.InvocationTargetException
    at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
    at java.lang.reflect.Method.invoke(Unknown Source)
    at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:413)
    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:336)
    ... 6 more
Caused by: java.lang.OutOfMemoryError: Metaspace
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(Unknown Source)
    ... 11 more
</code></pre></div></div>

<p><strong>针对jvm8优化</strong></p>

<ul>
  <li>在内存较低的机器如(4c8g),jvm本身可能占用较大内存如2g，这将限制元数据的大小可能导致OOM异常,合理计算内存</li>
</ul>

<h2 id="参考文献">参考文献</h2>

<p><a href="https://www.cnblogs.com/xrq730/p/8688203.html">Java虚拟机16：Metaspace</a></p>

:ET