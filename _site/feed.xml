<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>思考生活</title>
    <description>Think-life - 思考而创作</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 02 Jan 2020 15:42:58 +0800</pubDate>
    <lastBuildDate>Thu, 02 Jan 2020 15:42:58 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>linux下R 3.6.0的安装手册</title>
        <description>&lt;h1 id=&quot;linux下r-360的安装手册&quot;&gt;linux下R 3.6.0的安装手册&lt;/h1&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言：&lt;/h2&gt;

&lt;p&gt;在RHEL 7.2部署R3.6.0的时候，踩过了不少坑，其中系统的某些组件版本过低导致R安装不成功，此篇文章总结了一下正确安装R3.6.0的正确姿势，希望对想进行部署环境的人有所帮助。&lt;/p&gt;

&lt;h2 id=&quot;1-相关环境配置&quot;&gt;1. 相关环境配置：&lt;/h2&gt;

&lt;h3 id=&quot;gcc-447&quot;&gt;Gcc 4.4.7&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@localhost ~]# gcc &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
Using built-in specs.
Target: x86_64-redhat-linux
Configured with: ../configure &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr &lt;span class=&quot;nt&quot;&gt;--mandir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/share/man &lt;span class=&quot;nt&quot;&gt;--infodir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/share/info &lt;span class=&quot;nt&quot;&gt;--with-bugurl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://bugzilla.redhat.com/bugzilla &lt;span class=&quot;nt&quot;&gt;--enable-bootstrap&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enable-shared&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enable-threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;posix &lt;span class=&quot;nt&quot;&gt;--enable-checking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;release &lt;span class=&quot;nt&quot;&gt;--with-system-zlib&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enable-__cxa_atexit&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--disable-libunwind-exceptions&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enable-gnu-unique-object&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enable-languages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;c,c++,objc,obj-c++,java,fortran,ada &lt;span class=&quot;nt&quot;&gt;--enable-java-awt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gtk &lt;span class=&quot;nt&quot;&gt;--disable-dssi&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--with-java-home&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre &lt;span class=&quot;nt&quot;&gt;--enable-libgcj-multifile&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enable-java-maintainer-mode&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--with-ecj-jar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/share/java/eclipse-ecj.jar &lt;span class=&quot;nt&quot;&gt;--disable-libjava-multilib&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--with-ppl&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--with-cloog&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--with-tune&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;generic &lt;span class=&quot;nt&quot;&gt;--with-arch_32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;i686 &lt;span class=&quot;nt&quot;&gt;--build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;x86_64-redhat-linux
Thread model: posix
gcc version 4.4.7 20120313 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Red Hat 4.4.7-23&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;GCC&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;操作系统&quot;&gt;操作系统：&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@localhost ~]# &lt;span class=&quot;nb&quot;&gt;uname&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
Linux localhost.localdomain 2.6.32-696.20.1.el6.x86_64 &lt;span class=&quot;c&quot;&gt;#1 SMP Fri Jan 26 17:51:45 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;r版本360&quot;&gt;R版本：3.6.0&lt;/h3&gt;

&lt;p&gt;linux64下面安装R的环境发现，有一些组件太旧了，所以需要先升级一些组件，才能安装R的3.6.0版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根据踩过的坑，罗列了一下需要升级IDE安装包。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;2r-360依赖升级的包&quot;&gt;2.R 3.6.0依赖升级的包&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;bzip2&amp;gt;=1.0.6，下载路径：https://nchc.dl.sourceforge.net/project/bzip2/bzip2-1.0.6.tar.gz&lt;/li&gt;
  &lt;li&gt;curl version 7 and &amp;gt;= 7.22.0，下载路径：https://curl.haxx.se/download/curl-7.22.0.tar.gz&lt;/li&gt;
  &lt;li&gt;PCRE version &amp;gt;= 8.20, &amp;lt; 10.0 and has UTF-8 support：ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/&lt;/li&gt;
  &lt;li&gt;xz-lzma version &amp;gt;= 5.0.3，下载路径：https://nchc.dl.sourceforge.net/project/lzmautils/xz-5.2.3.tar.gz&lt;/li&gt;
  &lt;li&gt;zlib version &amp;gt;= 1.2.5，下载路径：https://zlib.net/zlib-1.2.11.tar.gz&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;下载好后的安装包结果如下&quot;&gt;下载好后的安装包结果如下：&lt;/h2&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@localhost R-depends]# ll
total 7740
drwxr-xr-x.  2 root root     4096 Jun  1 01:52 bzip2-1.0.6
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;  1 root root   782025 Nov  4  2018 bzip2-1.0.6.tar.gz
drwxr-xr-x. 11 1000  1000    4096 Jun  1 01:56 curl-7.22.0
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;  1 root root  2957090 Jun  1 01:54 curl-7.22.0.tar.gz
drwxr-xr-x.  9 1169  1169   12288 Jun  1 01:58 pcre-8.38
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;  1 root root  2053336 Jun  1 01:49 pcre-8.38.tar.gz
drwxr-xr-x. 14 root root     4096 Jun  1 01:59 xz-5.2.3
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;  1 root root  1490665 Dec 30  2016 xz-5.2.3.tar.gz
drwxr-xr-x. 14  501 games    4096 Jun  1 02:14 zlib-1.2.11
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;  1 root root   607698 Jan 16  2017 zlib-1.2.11.tar.gz

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;解决bzip2从105升级到106的方法&quot;&gt;解决bzip2从1.0.5升级到1.0.6的方法&lt;/h3&gt;

&lt;p&gt;在linux64的系统上，下载好后的bzip2默认不是用64位进行编译的，所以直接安装的时候回出错，如果你用的是linux32位的就没有问题，以下罗列了出现的安装错误：&lt;/p&gt;

&lt;p&gt;Ø libbz2.a: could not read symbols: Bad value——&amp;gt;把/usr/local/lib中的libbz2.a删掉&lt;/p&gt;

&lt;p&gt;Ø /usr/local/lib/libz.a: could not read symbols——–&amp;gt;操作同上，删掉libz.a;&lt;/p&gt;

&lt;h4 id=&quot;1-修改bzip2-106的makefile文件&quot;&gt;1. 修改bzip2-1.0.6的”Makefile”文件：&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nv&quot;&gt;CC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gcc &lt;span class=&quot;nt&quot;&gt;-fPIC&lt;/span&gt;  &amp;lt;&amp;lt; 新增 &lt;span class=&quot;nt&quot;&gt;-fPIC&lt;/span&gt;，默认是64位编译的；
&lt;span class=&quot;nv&quot;&gt;AR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ar
&lt;span class=&quot;nv&quot;&gt;RANLIB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ranlib
&lt;span class=&quot;nv&quot;&gt;LDFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;BIGFILES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-D_FILE_OFFSET_BITS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;64
&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-fPIC&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Winline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-O2&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;  &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;BIGFILES&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;# 这里也可以加上&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-用命令行安装bzip2&quot;&gt;2. 用命令行安装bzip2：&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum remove bzip2-devel.x86_64 0:1.0.5-7.el6_0  &lt;span class=&quot;c&quot;&gt;#　先remove掉原来的bzip-1.0.5文件：&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bzip2-1.0.6
make &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Makefile-libbz2_so
make clean &amp;lt;&lt;span class=&quot;nt&quot;&gt;------------&lt;/span&gt;保守建议，还是clean一下 
make
make &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; xxx/xxx   &lt;span class=&quot;c&quot;&gt;# prefix表示的安装的路径前缀&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-具体的安装步骤&quot;&gt;3. 具体的安装步骤&lt;/h4&gt;

&lt;p&gt;首先依次升级低版本的包，具体安装步骤如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新建一个文件夹，然后把需要依赖的组件安装这个路径下&lt;/li&gt;
  &lt;li&gt;安装相应的依赖包，把包都安装在制定路径上；&lt;/li&gt;
  &lt;li&gt;修改一下path，新增这个文件夹路径，可以找到相应的环境；&lt;/li&gt;
  &lt;li&gt;最后安装R；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;首先看第一步进入linux系统&quot;&gt;首先看第一步，进入linux系统：&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;packages
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;#文件夹packages可以自行定义，这里&lt;/p&gt;

&lt;h2 id=&quot;各安装包的安装的报错和安装方法&quot;&gt;各安装包的安装的报错和安装方法&lt;/h2&gt;

&lt;h3 id=&quot;bzip2&quot;&gt;bzip2&lt;/h3&gt;

&lt;p&gt;报错结果：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;checking bzlib.h presence... &lt;span class=&quot;nb&quot;&gt;yes
&lt;/span&gt;checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;bzlib.h... &lt;span class=&quot;nb&quot;&gt;yes
&lt;/span&gt;checking &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;bzip2 version &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; 1.0.6... no
checking whether bzip2 support suffices...
configure: 
error: bzip2 library and headers are required
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体命令，把bzip2的文件&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;tar &lt;/span&gt;xzvf bzip2-1.0.6.tar.gz
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bzip2-1.0.6
make &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Makefile-libbz2_so
make clean
make
make &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/packages
make &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/packages
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;curl&quot;&gt;curl&lt;/h3&gt;

&lt;p&gt;报错：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;checking libcurl version ... 7.19.7
checking curl/curl.h usability... &lt;span class=&quot;nb&quot;&gt;yes
&lt;/span&gt;checking curl/curl.h presence... &lt;span class=&quot;nb&quot;&gt;yes
&lt;/span&gt;checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;curl/curl.h... &lt;span class=&quot;nb&quot;&gt;yes
&lt;/span&gt;checking &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;libcurl is version 7 and &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;
7.28.0... no
configure: error: libcurl &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; 7.28.0
library and headers are 
required with support &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;https

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; –xvf curl-7.54.1.tar.gz
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;curl
./configure &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/packages   &lt;span class=&quot;c&quot;&gt;# 这个是之前设置的packages路径&lt;/span&gt;
make &lt;span class=&quot;nt&quot;&gt;-j3&lt;/span&gt;
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pcre&quot;&gt;pcre&lt;/h3&gt;

&lt;p&gt;报错内容：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;pcre/pcre.h... no
checking &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;PCRE version &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; 8.10, &amp;lt;
10.0 and has UTF-8 support... no checking whether PCRE support suffices...
configure: error: pcre &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; 8.10 library and headers are required

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; –xvf pcre-8.41.tar.gz
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;pcre
./configure &lt;span class=&quot;nt&quot;&gt;--enable-utf8&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/packages &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 这个是之前设置的packages路径，一定要设置enable-utf8;&lt;/span&gt;
make
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;xz&quot;&gt;xz&lt;/h3&gt;

&lt;p&gt;报错方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;checking whether bzip2 support suffices...
no
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;lzma_version_number &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-llzma&lt;/span&gt;... no
configure: error: &lt;span class=&quot;s2&quot;&gt;&quot;liblzma library and
headers are required&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;tar &lt;/span&gt;xzvf xz-5.2.3.tar.gz
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;xz-5.2.3
./configure &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/packages
make &lt;span class=&quot;nt&quot;&gt;-j3&lt;/span&gt;
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;zlib&quot;&gt;zlib&lt;/h3&gt;

&lt;p&gt;报错信息：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;checking &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;zlib version &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; 1.2.5... no
checking whether zlib support suffices...
configure: error: zlib library and headers are required

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-zxvf&lt;/span&gt; zlib-1.2.11.tar.gz

&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zlib-1.2.11/

./configure &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/zlib

make

make check

make &lt;span class=&quot;nb&quot;&gt;install

echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/local/zlib/lib&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /etc/ld.so.conf 

ldconfig &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-设置环境变量安装r-devel的时候需要找到相应的组件&quot;&gt;4. 设置环境变量，安装R devel的时候需要找到相应的组件&lt;/h2&gt;

&lt;h3 id=&quot;设置pathcflagsldflags等路径&quot;&gt;设置path，CFLAGS，LDFLAGS等路径；&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/packages/bin:&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;LD_LIBRARY_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/packages/lib:&lt;span class=&quot;nv&quot;&gt;$LD_LIBRARY_PATH&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-I&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/packages/include&quot;&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;export  &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;LDFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-L&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/packages/lib&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;5-安装r360&quot;&gt;5. 安装R3.6.0&lt;/h2&gt;

&lt;p&gt;安装R-liunx版本：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;gcc  gcc-gfortran  gcc-c++  glibc-headers  libreadline6-dev gfortran   readline-devel  wget libXt-devel  fonts-chinese tcl tcl-devel tclx tk tk-devel  mesa-libGLU mesa-libGLU-devel  &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;bzip2-devel   &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;xz-devel.x86_64   &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;pcre-devel  &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;libcurl  &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;libcurl-devel   texinfo.x86_64  texlive-pdftex-doc.noarch  texlive

&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; –xvf R-3.6.0.tar.gz
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;R-3.6.0
&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt;  ./configure &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/lib64/R  &lt;span class=&quot;nt&quot;&gt;--enable-R-shlib&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;--with-readline&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;yes&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--with-libpng&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;yes&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--with-x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;no  &lt;span class=&quot;c&quot;&gt;# --enable-R-shlib一定要设置，否则安装不上Rserve;  prefix是安装路径，可以自定义；&lt;/span&gt;
make &lt;span class=&quot;nt&quot;&gt;-j3&lt;/span&gt;
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;6-设置环境变量&quot;&gt;6 设置环境变量&lt;/h2&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
vim /etc/profile
&lt;span class=&quot;nv&quot;&gt;R_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/software/R-3.6.0
&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;nv&quot;&gt;$R_HOME&lt;/span&gt;/bin
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;7检验&quot;&gt;7、检验&lt;/h2&gt;

&lt;p&gt;在终端输入&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@localhost R-3.6.0]# R

R version 3.6.0 (2019-04-26) -- &quot;Planting of a Tree&quot;
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示R已经安装好了&lt;/p&gt;

&lt;h2 id=&quot;7-安装r的包或者rserve用来进行外部通讯&quot;&gt;7. 安装R的包或者Rserve，用来进行外部通讯&lt;/h2&gt;

&lt;h3 id=&quot;启动r&quot;&gt;启动R&lt;/h3&gt;

&lt;p&gt;Rserve #在R的console里面执行下面的命令&lt;/p&gt;

&lt;p&gt;1.下载安装包复制到服务器上 地址：Rserve - Binary R server - download/files - RForge.net(http://www.rforge.net/Rserve/files/)&lt;/p&gt;

&lt;p&gt;2.install.packages(“Rserve安装包的绝对路径”) 或者 &lt;strong&gt;在终端执行&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;R CMD INSTALL Rserve_1.8-3.tar.gz

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.library(“Rserve”)，进入R界面，然后启动library(Rserve)启动；Rserve&lt;/p&gt;

&lt;p&gt;或者用命令行，用命令行可以用进程控制，R client只能是线程控制，退出界面后就无法访问了&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
/usr/local/lib64/R/bin/R CMD /home/op1/R/x86_64-unknown-linux-gnu-library/3.2/Rserve/libs/Rserve

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.查看后台进程&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
ps aux | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;Rserve &lt;span class=&quot;c&quot;&gt;# 命令查看Rserve进程&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.开启远程访问&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
R CMD  /home/op1/R/x86_64-unknown-linux-gnu-library/3.2/Rserve/libs//Rserve  &lt;span class=&quot;nt&quot;&gt;--RS-enable-remote&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#开启远程访问&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;附录&quot;&gt;附录：&lt;/h2&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料：　&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Building R-devel on RedHat Linux (https://link.zhihu.com/?target=http%3A//pj.freefaculty.org/blog/%3Fp%3D315)　写的也和详细，我把我碰到的问题做了一些顺序的调整；&lt;/li&gt;
  &lt;li&gt;linux下R3.4.1的安装手册 (https://zhuanlan.zhihu.com/p/28055351)&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 12 Jun 2019 21:45:45 +0800</pubDate>
        <link>http://localhost:4000/2019/06/12/install-R-language/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/12/install-R-language/</guid>
        
        <category>技术杂谈</category>
        
        
      </item>
    
      <item>
        <title>Java虚拟机：Metaspace</title>
        <description>&lt;h1 id=&quot;java虚拟机metaspace&quot;&gt;Java虚拟机：Metaspace&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;被废弃的持久代&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想起之前面试的时候有面试官问起过我一个问题：Java 8为什么要废弃持久代即Metaspace的作用。由于当时使用的Java 7且研究重心不在JVM上，一下没有回答上来，今天突然想起这个问题，就详细总结一下这个问题。&lt;/p&gt;

&lt;p&gt;首先我们看一张JVM内存布局的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201804/801753-20180401164846766-809607195.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意到里面有一块METHOD AREA，它是一块线程共享的对象，名为方法区，在HotSpot虚拟机中，这块METHOD AREA我们可以认为等同于持久代（PermGen），在Java 6及之前的版本，持久代存放了以下一些内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;虚拟机加载的类信息&lt;/li&gt;
  &lt;li&gt;常量池&lt;/li&gt;
  &lt;li&gt;静态变量&lt;/li&gt;
  &lt;li&gt;即时编译后的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到了&lt;strong&gt;Java 7之后，常量池已经不在持久代之中进行分配了，而是移到了堆中&lt;/strong&gt;，即常量池和对象共享堆内存。&lt;/p&gt;

&lt;p&gt;接着到了Java 8之后的版本（至此篇文章，Java 10刚发布），持久代已经被永久移除，取而代之的是Metaspace。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么要移除持久代&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HotSpot团队选择移除持久代，有内因和外因两部分，从外因来说，我们看一下&lt;a href=&quot;http://openjdk.java.net/jeps/122&quot;&gt;JEP 122&lt;/a&gt;的Motivation（动机）部分：&lt;/p&gt;

&lt;pre&gt;
This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.
&lt;/pre&gt;

&lt;p&gt;这是JRockit和Hotspot融合工作的一部分。JRockit客户不需要配置永久代（因为JRockit没有永久代）并且习惯于不配置永久代。&lt;/p&gt;

&lt;p&gt;将Hotspot中永久代的部分内容移动到Java堆，将剩余部分的内容移动到本机内存。&lt;/p&gt;

&lt;p&gt;Hotspot对Java类的表示（此处称为类元数据）当前存储在Java堆的一部分中，称为永久生成。此外，实体化的字符串和类静态变量存储在永久代中。永久代由Hotspot管理，并且必须有足够的空间容纳所有类元数据，Java应用程序使用的内部字符串和类静态。类加载类时，在永久代中分配类元数据和静态，并在卸载类时从永久代收集垃圾。当永久代生成GC时，Interned Strings也会被垃圾收集。&lt;/p&gt;

&lt;p&gt;建议的实现将在本机内存中分配类元数据，并将实际的字符串和类静态移动到Java堆。Hotspot将为类元数据显式分配和释放本机内存。新类元数据的分配将受可用本机内存量的限制，而不是由-XX：MaxPermSize的值固定，无论是默认值还是在命令行上指定。&lt;/p&gt;

&lt;p&gt;用于类元数据的本机存储器的分配将以足够大的块来完成，以适合多个类元数据。每个块都将与一个类加载器相关联，并且该类加载器加载的所有类元数据将由Hotspot从该类加载器的块中分配。根据需要，将为类加载器分配附加块。块大小将根据应用程序的行为而变化。将选择尺寸以限制内部和外部碎片。当类加载器通过释放与类加载器相关联的所有块而死亡时，将释放类元数据的空间。类的元数据在课程期间不会被移动。&lt;/p&gt;

&lt;p&gt;从内因来说，持久代大小受到-XX：PermSize和-XX：MaxPermSize两个参数的限制，而这两个参数又受到JVM设定的内存大小限制，这就导致&lt;strong&gt;在使用中可能会出现持久代内存溢出的问题&lt;/strong&gt;，因此在Java 8及之后的版本中彻底移除了持久代而使用Metaspace来进行替代。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Metaspace&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上面说了，为了避免出现持久代内存溢出的问题; 并且可以支持不同应用程序之间进行类共享而减少内存开销(可能会降低性能)，，Java 8及之后的版本彻底移除了持久代而使用Metaspace来进行替代。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Metaspace是方法区在HotSpot中的实现，它与持久代最大的区别在于：&lt;strong&gt;Metaspace并不在虚拟机内存中而是使用本地内存&lt;/strong&gt;。因此Metaspace具体大小理论上取决于32位/64位系统可用内存的大小，可见也不是无限制的，需要配置参数。&lt;/p&gt;

&lt;p&gt;接着我们模拟一下Metaspace内存溢出的情况，前面说了持久代存放了以下信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;虚拟机加载的类信息(类元数据)&lt;/li&gt;
  &lt;li&gt;实体化的字符串&lt;/li&gt;
  &lt;li&gt;静态类变量&lt;/li&gt;
  &lt;li&gt;常量池&lt;/li&gt;
  &lt;li&gt;即时编译后的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以最简单的模拟Metaspace内存溢出，我们只需要无限生成类信息即可，类占据的空间总是会超过Metaspace指定的空间大小的，下面用Cglib来模拟：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MetaspaceOOMTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * JVM参数:-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=128m -XX:+PrintFlagsInitial
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
                
                &lt;span class=&quot;nc&quot;&gt;Enhancer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enhancer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Enhancer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;enhancer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setSuperclass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;OOMObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;enhancer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setUseCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;enhancer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MethodInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intercept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MethodProxy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invokeSuper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;enhancer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;第&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;次时发生异常&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OOMObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;虚拟机参数设置为”-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=128m”，运行代码，结果为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第15562次时发生异常
net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&amp;gt;null
    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:345)
    at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)
    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:114)
    at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291)
    at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)
    at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)
    at org.xrq.commom.test.jvm.MetaspaceOOMTest.main(MetaspaceOOMTest.java:34)
Caused by: java.lang.reflect.InvocationTargetException
    at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
    at java.lang.reflect.Method.invoke(Unknown Source)
    at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:413)
    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:336)
    ... 6 more
Caused by: java.lang.OutOfMemoryError: Metaspace
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(Unknown Source)
    ... 11 more
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;针对jvm8优化&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在内存较低的机器如(4c8g),jvm本身可能占用较大内存如2g，这将限制元数据的大小可能导致OOM异常,合理计算内存&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xrq730/p/8688203.html&quot;&gt;Java虚拟机16：Metaspace&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 01 Jan 2019 18:18:56 +0800</pubDate>
        <link>http://localhost:4000/2019/01/01/hotspot-jvm8-metaspace-16/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/01/hotspot-jvm8-metaspace-16/</guid>
        
        <category>jvm虚拟机</category>
        
        
      </item>
    
      <item>
        <title>curl和wget常用命令</title>
        <description>&lt;h1 id=&quot;curl和wget常用命令&quot;&gt;curl和wget常用命令&lt;/h1&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://gist.github.com/303182519/132568fd0e58cae57202#file-curl-md&lt;/li&gt;
  &lt;li&gt;http://bbs.et8.net/bbs/showthread.php?t=568472&lt;/li&gt;
  &lt;li&gt;http://www.ruanyifeng.com/blog/2011/09/curl.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;下载单个文件默认将输出打印到标准输出中stdout中&quot;&gt;下载单个文件，默认将输出打印到标准输出中(STDOUT)中&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://www.centos.org
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;通过-o-o选项保存下载的文件到指定的文件中&quot;&gt;通过-o/-O选项保存下载的文件到指定的文件中：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;-o：将文件保存为命令行中指定的文件名的文件中&lt;/li&gt;
    &lt;li&gt;-O：使用URL中默认的文件名保存文件到本地&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将文件下载到本地并命名为mygettext.html
  curl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html
 
# 将文件保存到本地并命名为gettext.html
  curl -O http://www.gnu.org/software/gettext/manual/gettext.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样可以使用转向字符”&amp;gt;”对输出进行转向输出&lt;/p&gt;

&lt;h3 id=&quot;同时获取多个文件&quot;&gt;同时获取多个文件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -O URL1 -O URL2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;若同时从同一站点下载多个文件时，curl会尝试重用链接(connection)。&lt;/p&gt;

&lt;p&gt;通过-L选项进行重定向
默认情况下CURL不会发送HTTP Location headers(重定向).当一个被请求页面移动到另一个站点时，会发送一个HTTP Loaction header作为请求，然后将请求重定向到新的地址上。
例如：访问google.com时，会自动将地址重定向到google.com.hk上。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://www.google.com
&amp;lt;HTML&amp;gt;
&amp;lt;HEAD&amp;gt;
    &amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&amp;gt;
    &amp;lt;TITLE&amp;gt;302 Moved&amp;lt;/TITLE&amp;gt;
&amp;lt;/HEAD&amp;gt;
&amp;lt;BODY&amp;gt;
    &amp;lt;H1&amp;gt;302 Moved&amp;lt;/H1&amp;gt;
    The document has moved
    &amp;lt;A HREF=&quot;http://www.google.com.hk/url?sa=p&amp;amp;amp;hl=zh-CN&amp;amp;amp;pref=hkredirect&amp;amp;amp;pval=yes&amp;amp;amp;q=http://www.google.com.hk/&amp;amp;amp;ust=1379402837567135amp;usg=AFQjCNF3o7umf3jyJpNDPuF7KTibavE4aA&quot;&amp;gt;here&amp;lt;/A&amp;gt;.
&amp;lt;/BODY&amp;gt;
&amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述输出说明所请求的档案被转移到了http://www.google.com.hk。&lt;/p&gt;

&lt;p&gt;这是可以通过使用-L选项进行强制重定向&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;让curl使用地址重定向，此时会查询google.com.hk站点
curl -L http://www.google.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;断点续传&quot;&gt;断点续传&lt;/h3&gt;

&lt;p&gt;通过使用-C选项可对大文件使用断点续传功能，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 当文件在下载完成之前结束该进程
$ curl -O http://www.gnu.org/software/gettext/manual/gettext.html
##############             20.1%

# 通过添加-C选项继续对该文件进行下载，已经下载过的文件不会被重新下载
curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html
###############            21.1%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;对curl使用网络限速&quot;&gt;对CURL使用网络限速&lt;/h3&gt;

&lt;p&gt;通过–limit-rate选项对CURL的最大网络使用进行限制&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;下载速度最大不会超过1000B/second
 
curl --limit-rate 1000B -O http://www.gnu.org/software/gettext/manual/gettext.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下载指定时间内修改过的文件&lt;/p&gt;

&lt;p&gt;当下载一个文件时，可对该文件的最后修改日期进行判断，如果该文件在指定日期内修改过，就进行下载，否则不下载。
该功能可通过使用-z选项来实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;若yy.html文件在2011/12/21之后有过更新才会进行下载
curl -z 21-Dec-11 http://www.example.com/yy.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;curl授权&quot;&gt;CURL授权&lt;/h3&gt;

&lt;p&gt;在访问需要授权的页面时，可通过-u选项提供用户名和密码进行授权&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; curl -u username:password URL
 
 # 通常的做法是在命令行只输入用户名，之后会提示输入密码，这样可以保证在查看历史记录时不会将密码泄露
 curl -u username URL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;从ftp服务器下载文件&quot;&gt;从FTP服务器下载文件&lt;/h3&gt;

&lt;p&gt;CURL同样支持FTP下载，若在url中指定的是某个文件路径而非具体的某个要下载的文件名，CURL则会列出该目录下的所有文件名而并非下载该目录下的所有文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 列出public_html下的所有文件夹和文件
 curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/
 
 # 下载xss.php文件
 curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/xss.php
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;上传文件到ftp服务器&quot;&gt;上传文件到FTP服务器&lt;/h3&gt;

&lt;p&gt;通过 -T 选项可将指定的本地文件上传到FTP服务器上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将myfile.txt文件上传到服务器
curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com

# 同时上传多个文件
curl -u ftpuser:ftppass -T &quot;{file1,file2}&quot; ftp://ftp.testserver.com

# 从标准输入获取内容保存到服务器指定的文件中
curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;获取更多信息&quot;&gt;获取更多信息&lt;/h3&gt;

&lt;p&gt;通过使用 -v 和 -trace获取更多的链接信息&lt;/p&gt;

&lt;h3 id=&quot;通过字典查询单词&quot;&gt;通过字典查询单词&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查询bash单词的含义
curl dict://dict.org/d:bash

# 列出所有可用词典
curl dict://dict.org/show:db

# 在foldoc词典中查询bash单词的含义
curl dict://dict.org/d:bash:foldoc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;为curl设置代理&quot;&gt;为CURL设置代理&lt;/h3&gt;

&lt;p&gt;x 选项可以为CURL添加代理功能&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 指定代理主机和端口
 curl -x proxysever.test.com:3128 http://google.co.in
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;保存与使用网站cookie信息&quot;&gt;保存与使用网站cookie信息&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 将网站的cookies信息保存到sugarcookies文件中
 curl -D sugarcookies http://localhost/sugarcrm/index.php
 
 # 使用上次保存的cookie信息
 curl -b sugarcookies http://localhost/sugarcrm/index.php
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;传递请求数据&quot;&gt;传递请求数据&lt;/h3&gt;

&lt;p&gt;默认curl使用GET方式请求数据，这种方式下直接通过URL传递数据
可以通过 –data/-d 方式指定使用POST方式传递数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET
curl -u username https://api.github.com/user?access_token=XXXXXXXXXX

# POST
curl -u username --data &quot;param1=value1&amp;amp;param2=value&quot; https://api.github.com

# 也可以指定一个文件，将该文件中的内容当作数据传递给服务器端
curl --data @filename https://github.api.com/authorizations
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注：默认情况下，通过POST方式传递过去的数据中若有特殊字符，首先需要将特殊字符转义在传递给服务器端，如value值中包含有空格，则需要先将空格转换成%20，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -d &quot;value%201&quot; http://hostname.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在新版本的CURL中，提供了新的选项 –data-urlencode，通过该选项提供的参数会自动转义特殊字符。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl --data-urlencode &quot;value 1&quot; http://hostname.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除了使用GET和POST协议外，还可以通过 -X 选项指定其它协议，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -I -X DELETE https://api.github.cim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上传文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl --form &quot;fileupload=@filename.txt&quot; http://hostname/resource
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 31 Dec 2018 18:18:56 +0800</pubDate>
        <link>http://localhost:4000/2018/12/31/wget-with-curl/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/31/wget-with-curl/</guid>
        
        <category>markdown</category>
        
        
      </item>
    
      <item>
        <title>如何通过Wireshark查看HTTPS、HTTP/2网络包（解码TLS、SSL）</title>
        <description>&lt;h1 id=&quot;如何通过wireshark查看httpshttp2网络包解码tlsssl&quot;&gt;如何通过Wireshark查看HTTPS、HTTP/2网络包（解码TLS、SSL）&lt;/h1&gt;

&lt;p&gt;2015年12月15日&lt;/p&gt;

&lt;p&gt;最近正在做HTTP/2相关的研究，由于目前所有的浏览器仅支持在HTTPS上使用HTTP/2，所以通过Wireshark只能查看到加密后的TLS网络包。其实Wireshark提供了一些设置允许我们解码TLS、SSL网络包。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot1.png&quot; alt=&quot;加密的TLS网络包&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;用服务器证书私钥解码&quot;&gt;用服务器证书私钥解码&lt;/h2&gt;

&lt;p&gt;第一种方法是：使用服务器证书的私钥进行解码。&lt;/p&gt;

&lt;h3 id=&quot;在iis上导出服务器证书私钥&quot;&gt;在IIS上导出服务器证书私钥&lt;/h3&gt;

&lt;p&gt;第一步我们需要从网站服务器上导出证书私钥，这里拿IIS服务器举例。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;打开IIS站点所绑定的服务器证书，点击查看 &lt;strong&gt;详细信息&lt;/strong&gt; 页，点击 &lt;strong&gt;复制到文件&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_iis.png&quot; alt=&quot;查看证书详情页-&amp;gt;复制到文件&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向导中点击下一步，当询问是否导出私钥时选择 &lt;strong&gt;是，导出私钥&lt;/strong&gt;，点击 &lt;strong&gt;下一步&lt;/strong&gt; 继续。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_iis2.png&quot; alt=&quot;是，导出私钥&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择 &lt;strong&gt;个人信息交换（.PFX）&lt;/strong&gt;，下面的三个复选框不用勾选，点击 &lt;strong&gt;下一步&lt;/strong&gt; 继续。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_iis3.png&quot; alt=&quot;个人信息交换（.PFX）&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;勾选 &lt;strong&gt;密码&lt;/strong&gt;，设置一个密码，点击 &lt;strong&gt;下一步&lt;/strong&gt; 继续，导出PFX文件。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_iis3.png&quot; alt=&quot;设置密码&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;wireshark中设置以服务器证书私钥解码ssl协议&quot;&gt;Wireshark中设置以服务器证书私钥解码SSL协议&lt;/h3&gt;

&lt;p&gt;有了PFX私钥文件，接下来就可以通过Wireshark设置使用该私钥来解码SSL、TLS网络包了。这一步既可以在服务器上的Wireshark中设置，也可以在客户端的Wireshark中设置，取决于你想在哪一端查看（抓取）网络包。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在Wireshark中，进入菜单 &lt;strong&gt;Edit&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Preferences…&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;展开 &lt;strong&gt;Protocols&lt;/strong&gt; -&amp;gt; &lt;strong&gt;SSL&lt;/strong&gt;，点击 &lt;strong&gt;Edit&lt;/strong&gt; 按钮编辑 &lt;strong&gt;RSA key lists&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot2.png&quot; alt=&quot;点击Edit编辑RSA key lists&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;配置如下：
    &lt;ul&gt;
      &lt;li&gt;IP address：目标服务器的IP地址，也可以填写 “any” 应用到所有IP地址。&lt;/li&gt;
      &lt;li&gt;Port：HTTPS端口号，一般均为：”443”。&lt;/li&gt;
      &lt;li&gt;Protocol：填写 “http”。&lt;/li&gt;
      &lt;li&gt;Key File：选取刚才导出的服务器证书私钥（PFX文件）。&lt;/li&gt;
      &lt;li&gt;Password：输入服务器证书私钥的密码。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;设置完成后，当前正在查看的网络包或将来抓取的网络包就会以设定的规则解码了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot4.png&quot; alt=&quot;解码后的TLS网络包&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果网络包依然无法被解码，那么很有可能是因为服务器和客户端之间使用了Diffie-Hellman加密算法。&lt;/p&gt;

&lt;h3 id=&quot;禁用diffie-hellman&quot;&gt;禁用Diffie-Hellman&lt;/h3&gt;

&lt;p&gt;如果在SSL、TLS握手过程中发现服务器返回的Server Hello所选择的加密算法带有 “&lt;strong&gt;ECDHE&lt;/strong&gt;” 和 “&lt;strong&gt;DHE&lt;/strong&gt;” 关键字，那就说明当前SSL Session使用了Diffie-Hellman加密算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot5.png&quot; alt=&quot;使用了Diffie-Hellman加密算法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用了Diffie-Hellman的TLS Session Key会用一个动态产生的密钥对进行加密，而不是使用证书的公钥加密，所以Wireshark依然无法解码TLS网络包。解决方案就是：&lt;strong&gt;禁用客户端或服务器的Diffie-Hellman加密算法&lt;/strong&gt;，建议禁用客户端的Diffie-Hellman加密算法仅供网络包分析，这样依然可以保持网站服务器的安全性。&lt;/p&gt;

&lt;p&gt;以下是从Windows客户端禁用三种不同浏览器Diffie-Hellman加密算法的方法以及禁用IIS服务器Diffie-Hellman加密算法，只要任选其一保证SSL Session不使用Diffie-Hellman加密算法即可。&lt;/p&gt;

&lt;h5 id=&quot;禁用internet-explorer的diffie-hellman加密算法&quot;&gt;禁用Internet Explorer的Diffie-Hellman加密算法&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;运行 &lt;strong&gt;gpedit.msc&lt;/strong&gt; 打开本地组策略编辑器。&lt;/li&gt;
  &lt;li&gt;编辑设置：&lt;strong&gt;计算机配置 -&amp;gt; 管理模板 -&amp;gt; 网络 -&amp;gt; SSL配置设置 -&amp;gt; SSL密码套件顺序&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用该设置后，复制文本框中的默认值到写字板或编辑器中。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_ssl1.png&quot; alt=&quot;启用设置：SSL密码套件顺序&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除所有带 “&lt;strong&gt;ECDHE&lt;/strong&gt;” 和 “&lt;strong&gt;DHE&lt;/strong&gt;” 的算法，请保持所有的文本都在一行里。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_ssl2.png&quot; alt=&quot;删除所有带ECDHE和DHE的算法&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将修改后的值替换原有的默认值，点击确定后保存，重启计算机。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启后，再次抓包发现IE发出的Client Hello中已经不包含任何Diffie-Hellman加密算法了，并且Wireshark已经能成功将TLS、SSL网络包解码。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_ssl3.png&quot; alt=&quot;Client Hello中已不包含任何Diffie-Hellman加密算法&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;禁用chrome的diffie-hellman加密算法&quot;&gt;禁用Chrome的Diffie-Hellman加密算法&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看默认Chrome发出的Client Hello包中所包含的Cipher Suites列表。&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     Cipher Suites &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;15 suites&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0xc02b&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0xc02f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x009e&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0xcc14&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0xcc13&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0xc00a&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0xc014&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_DHE_RSA_WITH_AES_256_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x0039&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0xc009&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0xc013&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x0033&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x009c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x0035&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x002f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x000a&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将所有带 “&lt;strong&gt;ECDHE&lt;/strong&gt;” 和 “&lt;strong&gt;DHE&lt;/strong&gt;” 的算法的十六进制表达连接成字符串赋给 “&lt;strong&gt;–cipher-suite-blacklist&lt;/strong&gt;” 参数，在启动Chrome时添加这个参数。如：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;c:\Program Files (x86)\Google\chrome\Application\chrome.exe –cipher-suite-blacklist=0xc02b,0xc02f,0x009e,0xcc14,0xcc13,0xc00a,0xc014,0x0039,0xc009,0xc013,0x0033&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动后，再次抓包可以看到Chrome发出的Client Hello包中已经不包含任何Diffie-Hellman加密算法了。&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Cipher Suites &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4 suites&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x009c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x0035&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x002f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x000a&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;禁用firefox的diffie-hellman加密算法&quot;&gt;禁用Firefox的Diffie-Hellman加密算法&lt;/h5&gt;

&lt;p&gt;打开Firefox，地址栏输入 “about:config”，搜索 “dhe”，双击搜到的所有Diffie-Hellman算法将其 &lt;strong&gt;Value&lt;/strong&gt;值改为 &lt;strong&gt;false&lt;/strong&gt;， 重启Firefox即可生效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_firefox1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;禁用iis服务器的diffie-hellman加密算法&quot;&gt;禁用IIS服务器的Diffie-Hellman加密算法&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;以管理员权限打开 &lt;strong&gt;regedit&lt;/strong&gt;，双击编辑：&lt;strong&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Cryptography\Configuration\Local\SSL\00010002\Functions&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将所有带 “&lt;strong&gt;ECDHE&lt;/strong&gt;” 和 “&lt;strong&gt;DHE&lt;/strong&gt;” 的算法删除。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_firefox2.png&quot; alt=&quot;将所有带ECDHE和DHE的算法删除&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;保存更改，重启服务器即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;用sslkeylogfile解码&quot;&gt;用SSLKEYLOGFILE解码&lt;/h2&gt;

&lt;p&gt;第二种解码TLS、SSL的方法是：设置环境变量 &lt;strong&gt;SSLKEYLOGFILE&lt;/strong&gt;，将其指向一个可写入的文本文件。Chrome和Firefox在启动时会检查这个环境变量，如果存在的话，它会向指定的文件写入访问HTTPS站点时使用的密钥。我们可以在客户端配置Wireshark读取这个文件来解码TLS、 SSL网络包。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;右键&lt;strong&gt;计算机&lt;/strong&gt;，查看&lt;strong&gt;属性&lt;/strong&gt;，打开&lt;strong&gt;高级系统设置&lt;/strong&gt;，查看&lt;strong&gt;高级&lt;/strong&gt;选项卡，点击&lt;strong&gt;环境变量&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_sys1.png&quot; alt=&quot;右键计算机，查看属性，打开高级系统设置，查看高级选项卡，点击环境变量。&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个&lt;strong&gt;系统变量&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://static.joji.me/a/img/a76b6912e52c366ad3998988e9f98bdf.png&quot; alt=&quot;新建一个系统变量&quot; title=&quot;新建一个系统变量&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定变量名为：&lt;strong&gt;SSLKEYLOGFILE&lt;/strong&gt;，变量值为一个可写入的文本文件。文件夹必须提前创建，若文件尚未创建，可以打开Chrome或Firefox一下，文件会被自动创建。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_sys2.png&quot; alt=&quot;变量名：SSLKEYLOGFILE，变量值：一个可写入的文本文件&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Wireshark中，进入菜单 &lt;strong&gt;Edit&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Preferences…&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;展开 &lt;strong&gt;Protocols&lt;/strong&gt; -&amp;gt; &lt;strong&gt;SSL&lt;/strong&gt;，将 &lt;strong&gt;(Pre)-Master-Secret log filename&lt;/strong&gt; 设为步骤3中指定的值。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_sys3.png&quot; alt=&quot;在Wireshark中设置(Pre)-Master-Secret log filename为SSLKEYLOGFILE的值&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击确认后，就会正确解码HTTPS网络包了。使用 &lt;strong&gt;SSLKEYLOGFILE&lt;/strong&gt; 的好处就是它可以解Diffie-Hellman加密算法。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/arct/wireshark/wireshark_snapshot_sys4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;本文介绍了两种在Wireshark中解码TLS、SSL的方法，你可以斟酌它们的优缺点选择最适合你的方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;服务器私钥&lt;/p&gt;

    &lt;p&gt;优点：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;既可在客户端使用，又可以在服务端使用。&lt;/li&gt;
      &lt;li&gt;支持各种浏览器。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;缺点：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;需要得到服务器证书。&lt;/li&gt;
      &lt;li&gt;不支持Diffie-Hellman加密算法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SSLKEYLOGFILE&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;优点：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;支持Diffie-Hellman加密算法。&lt;/li&gt;
      &lt;li&gt;不需要取得服务器证书。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;缺点：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;只能在客户端使用。&lt;/li&gt;
      &lt;li&gt;只支持Chrome和Firefox。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 30 Nov 2018 21:45:45 +0800</pubDate>
        <link>http://localhost:4000/2018/11/30/Wireshark-01/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/30/Wireshark-01/</guid>
        
        <category>网络协议</category>
        
        <category>OSI网络模型</category>
        
        
      </item>
    
      <item>
        <title>jvm查询</title>
        <description>&lt;h1 id=&quot;jvm查询&quot;&gt;jvm查询&lt;/h1&gt;

&lt;h2 id=&quot;jvm查询cpu利用率高的线程&quot;&gt;jvm查询CPU利用率高的线程&lt;/h2&gt;

&lt;p&gt;1.使用top 定位到占用CPU高的进程PID&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;top 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过ps aux | grep PID命令&lt;/p&gt;

&lt;p&gt;2.获取线程信息，并找到占用CPU高的线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ps -mp pid -o THREAD,tid,time | sort -rn 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.将需要的线程ID转换为16进制格式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf &quot;%x\n&quot; tid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.打印线程的堆栈信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jstack pid |grep tid -A 30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 19 Nov 2018 19:15:06 +0800</pubDate>
        <link>http://localhost:4000/2018/11/19/jvm-optimization/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/19/jvm-optimization/</guid>
        
        <category>jvm虚拟机</category>
        
        
      </item>
    
      <item>
        <title>Zookeeper架构及FastLeaderElection机</title>
        <description>&lt;h1 id=&quot;深入浅出zookeeper一-zookeeper架构及fastleaderelection机制&quot;&gt;深入浅出Zookeeper（一） Zookeeper架构及FastLeaderElection机制&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文介绍了Zookeeper的架构，并组合实例分析了原子广播(ZAB)协议的原理，包括但不限于Zookeeper的读写流程，FastLeaderElection算法的原理，ZAB如何保证Leader Failover过程中的数据一致性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;原创文章，转载请务必将下面这段话置于文章开头处。&lt;br /&gt;
本文转发自&lt;a href=&quot;http://www.jasongj.com/&quot;&gt;&lt;strong&gt;技术世界&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection&quot;&gt;原文链接&lt;/a&gt;　&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection&quot;&gt;http://www.jasongj.com/zookeeper/fastleaderelection/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;zookeeper是什么&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#Zookeeper%E6%98%AF%E4%BB%80%E4%B9%88&quot; title=&quot;Zookeeper是什么&quot;&gt;&lt;/a&gt;Zookeeper是什么&lt;/h1&gt;

&lt;p&gt;Zookeeper是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。&lt;/p&gt;

&lt;p&gt;这一切的基础，都是Zookeeper提供了一个类似于Linux文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。&lt;/p&gt;

&lt;p&gt;既然是一个文件系统，就不得不提Zookeeper是如何保证数据的一致性的。本文将介绍Zookeeper如何保证数据一致性，如何进行领导选举，以及数据监控/通知机制的语义保证。&lt;/p&gt;

&lt;h1 id=&quot;zookeeper架构&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#Zookeeper%E6%9E%B6%E6%9E%84&quot; title=&quot;Zookeeper架构&quot;&gt;&lt;/a&gt;Zookeeper架构&lt;/h1&gt;

&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E8%A7%92%E8%89%B2&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;

&lt;p&gt;Zookeeper集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Leader&lt;/em&gt;&lt;/strong&gt; 一个Zookeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各Follwer及Observer间的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其它服务器。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Follower&lt;/em&gt;&lt;/strong&gt; 一个Zookeeper集群可能同时存在多个Follower，它会响应Leader的心跳。Follower可直接处理并返回客户端的读请求，同时会将写请求转发给Leader处理，并且负责在Leader处理写请求时对请求进行投票。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Observer&lt;/em&gt;&lt;/strong&gt; 角色与Follower类似，但是无投票权。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/architecture.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/architecture.png&quot; alt=&quot;Zookeeper Architecture&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;原子广播zab&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E5%8E%9F%E5%AD%90%E5%B9%BF%E6%92%AD%EF%BC%88ZAB%EF%BC%89&quot; title=&quot;原子广播（ZAB）&quot;&gt;&lt;/a&gt;原子广播（ZAB）&lt;/h2&gt;

&lt;p&gt;为了保证写操作的一致性与可用性，Zookeeper专门设计了一种名为原子广播（ZAB）的支持崩溃恢复的一致性协议。基于该协议，Zookeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。&lt;/p&gt;

&lt;p&gt;根据ZAB协议，所有的写操作都必须通过Leader完成，Leader写入本地日志后再复制到所有的Follower节点。&lt;/p&gt;

&lt;p&gt;一旦Leader节点无法工作，ZAB协议能够自动从Follower节点中重新选出一个合适的替代者，即新的Leader，该过程即为领导选举。该领导选举过程，是ZAB协议中最为重要和复杂的过程。&lt;/p&gt;

&lt;h2 id=&quot;写操作&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E5%86%99%E6%93%8D%E4%BD%9C&quot; title=&quot;写操作&quot;&gt;&lt;/a&gt;写操作&lt;/h2&gt;

&lt;h3 id=&quot;写leader&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E5%86%99Leader&quot; title=&quot;写Leader&quot;&gt;&lt;/a&gt;写Leader&lt;/h3&gt;

&lt;p&gt;通过Leader进行写操作流程如下图所示&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/writeleader.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/writeleader.png&quot; alt=&quot;Zookeeper Leader Write&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由上图可见，通过Leader进行写操作，主要分为五步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向Leader发起写请求&lt;/li&gt;
  &lt;li&gt;Leader将写请求以Proposal的形式发给所有Follower并等待ACK&lt;/li&gt;
  &lt;li&gt;Follower收到Leader的Proposal后返回ACK&lt;/li&gt;
  &lt;li&gt;Leader得到过半数的ACK（Leader对自己默认有一个ACK）后向所有的Follower和Observer发送Commmit&lt;/li&gt;
  &lt;li&gt;Leader将处理结果返回给客户端&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里要注意&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Leader并不需要得到Observer的ACK，即Observer无投票权&lt;/li&gt;
  &lt;li&gt;Leader不需要得到所有Follower的ACK，只要收到过半的ACK即可，同时Leader本身对自己有一个ACK。上图中有4个Follower，只需其中两个返回ACK即可，因为(2+1) / (4+1) &amp;gt; 1/2&lt;/li&gt;
  &lt;li&gt;Observer虽然无投票权，但仍须同步Leader的数据从而在处理读请求时可以返回尽可能新的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;写followerobserver&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E5%86%99Follower-Observer&quot; title=&quot;写Follower/Observer&quot;&gt;&lt;/a&gt;写Follower/Observer&lt;/h3&gt;

&lt;p&gt;通过Follower/Observer进行写操作流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/writefollower.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/writefollower.png&quot; alt=&quot;Zookeeper Follower/Observer Write&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从上图可见&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Follower/Observer均可接受写请求，但不能直接处理，而需要将写请求转发给Leader处理&lt;/li&gt;
  &lt;li&gt;除了多了一步请求转发，其它流程与直接写Leader无任何区别&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;读操作&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E8%AF%BB%E6%93%8D%E4%BD%9C&quot; title=&quot;读操作&quot;&gt;&lt;/a&gt;读操作&lt;/h2&gt;

&lt;p&gt;Leader/Follower/Observer都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/read.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/read.png&quot; alt=&quot;Zookeeper Read&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于处理读请求不需要服务器之间的交互，Follower/Observer越多，整体可处理的读请求量越大，也即读性能越好。&lt;/p&gt;

&lt;h1 id=&quot;fastleaderelection原理&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#FastLeaderElection%E5%8E%9F%E7%90%86&quot; title=&quot;FastLeaderElection原理&quot;&gt;&lt;/a&gt;FastLeaderElection原理&lt;/h1&gt;

&lt;h2 id=&quot;术语介绍&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E6%9C%AF%E8%AF%AD%E4%BB%8B%E7%BB%8D&quot; title=&quot;术语介绍&quot;&gt;&lt;/a&gt;术语介绍&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;myid&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
每个Zookeeper服务器，都需要在数据文件夹下创建一个名为myid的文件，该文件包含整个Zookeeper集群唯一的ID（整数）。例如某Zookeeper集群包含三台服务器，hostname分别为zoo1、zoo2和zoo3，其myid分别为1、2和3，则在配置文件中其ID与hostname必须一一对应，如下所示。在该配置文件中，&lt;code class=&quot;highlighter-rouge&quot;&gt;server.&lt;/code&gt;后面的数据即为myid&lt;/p&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;
    col 1                | col 2                                                                                 
    -------------------- | --------------------------------------------------------------------------------------
    &lt;pre&gt;
    1

    2

    3
    &lt;/pre&gt; | &lt;pre&gt;
    server.1=zoo1:2888:3888

    server.2=zoo2:2888:3888

    server.3=zoo3:2888:3888
    &lt;/pre&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;zxid&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
类似于RDBMS中的事务ID，用于标识一次更新操作的Proposal ID。为了保证顺序性，该zkid必须单调递增。因此Zookeeper使用一个64位的数来表示，高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加一。低32位为该epoch内的序号，每次epoch变化，都将低32位的序号重置。这样保证了zkid的全局递增性。&lt;/p&gt;

&lt;h2 id=&quot;支持的领导选举算法&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E6%94%AF%E6%8C%81%E7%9A%84%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95&quot; title=&quot;支持的领导选举算法&quot;&gt;&lt;/a&gt;支持的领导选举算法&lt;/h2&gt;

&lt;p&gt;可通过&lt;code class=&quot;highlighter-rouge&quot;&gt;electionAlg&lt;/code&gt;配置项设置Zookeeper用于领导选举的算法。&lt;/p&gt;

&lt;p&gt;到3.4.10版本为止，可选项有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; 基于UDP的LeaderElection&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 基于UDP的FastLeaderElection&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt; 基于UDP和认证的FastLeaderElection&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; 基于TCP的FastLeaderElection&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在3.4.10版本中，默认值为3，也即基于TCP的FastLeaderElection。另外三种算法已经被弃用，并且有计划在之后的版本中将它们彻底删除而不再支持。&lt;/p&gt;

&lt;h2 id=&quot;fastleaderelection&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#FastLeaderElection&quot; title=&quot;FastLeaderElection&quot;&gt;&lt;/a&gt;FastLeaderElection&lt;/h2&gt;

&lt;p&gt;FastLeaderElection选举算法是标准的Fast Paxos算法实现，可解决LeaderElection选举算法收敛速度慢的问题。&lt;/p&gt;

&lt;h3 id=&quot;服务器状态&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81&quot; title=&quot;服务器状态&quot;&gt;&lt;/a&gt;服务器状态&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;LOOKING&lt;/em&gt;&lt;/strong&gt; 不确定Leader状态。该状态下的服务器认为当前集群中没有Leader，会发起Leader选举&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;FOLLOWING&lt;/em&gt;&lt;/strong&gt; 跟随者状态。表明当前服务器角色是Follower，并且它知道Leader是谁&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;LEADING&lt;/em&gt;&lt;/strong&gt; 领导者状态。表明当前服务器角色是Leader，它会维护与Follower间的心跳&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;OBSERVING&lt;/em&gt;&lt;/strong&gt; 观察者状态。表明当前服务器角色是Observer，与Folower唯一的不同在于不参与选举，也不参与集群写操作时的投票&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;选票数据结构&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E9%80%89%E7%A5%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot; title=&quot;选票数据结构&quot;&gt;&lt;/a&gt;选票数据结构&lt;/h3&gt;

&lt;p&gt;每个服务器在进行领导选举时，会发送如下关键信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;logicClock&lt;/em&gt;&lt;/strong&gt; 每个服务器会维护一个自增的整数，名为logicClock，它表示这是该服务器发起的第多少轮投票&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;state&lt;/em&gt;&lt;/strong&gt; 当前服务器的状态&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;self_id&lt;/em&gt;&lt;/strong&gt; 当前服务器的myid&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;self_zxid&lt;/em&gt;&lt;/strong&gt; 当前服务器上所保存的数据的最大zxid&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;vote_id&lt;/em&gt;&lt;/strong&gt; 被推举的服务器的myid&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;vote_zxid&lt;/em&gt;&lt;/strong&gt; 被推举的服务器上所保存的数据的最大zxid&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;投票流程&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E6%8A%95%E7%A5%A8%E6%B5%81%E7%A8%8B&quot; title=&quot;投票流程&quot;&gt;&lt;/a&gt;投票流程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;自增选举轮次&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
Zookeeper规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的logicClock进行自增操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;初始化选票&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器2投票给服务器3，服务器3投票给服务器1，则服务器1的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;发送初始化选票&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
每个服务器最开始都是通过广播把票投给自己。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;接收外部投票&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;判断选举轮次&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
收到外部投票后，首先会根据投票信息中所包含的logicClock来进行不同处理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;外部投票的logicClock大于自己的logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的logicClock更新为收到的logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。&lt;/li&gt;
  &lt;li&gt;外部投票的logicClock小于自己的logicClock。当前服务器直接忽略该投票，继续处理下一个投票。&lt;/li&gt;
  &lt;li&gt;外部投票的logickClock与自己的相等。当时进行选票PK。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;选票PK&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
选票PK是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;外部投票的logicClock大于自己的logicClock，则将自己的logicClock及自己的选票的logicClock变更为收到的logicClock&lt;/li&gt;
  &lt;li&gt;若logicClock一致，则对比二者的vote_zxid，若外部投票的vote_zxid比较大，则将自己的票中的vote_zxid与vote_myid更新为收到的票中的vote_zxid与vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖&lt;/li&gt;
  &lt;li&gt;若二者vote_zxid一致，则比较二者的vote_myid，若外部投票的vote_myid比较大，则将自己的票中的vote_myid更新为收到的票中的vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;统计选票&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;更新服务器状态&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为LEADING，否则将自己的状态更新为FOLLOWING&lt;/p&gt;

&lt;h2 id=&quot;几种领导选举场景&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E5%87%A0%E7%A7%8D%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE%E5%9C%BA%E6%99%AF&quot; title=&quot;几种领导选举场景&quot;&gt;&lt;/a&gt;几种领导选举场景&lt;/h2&gt;

&lt;h3 id=&quot;集群启动领导选举&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE&quot; title=&quot;集群启动领导选举&quot;&gt;&lt;/a&gt;集群启动领导选举&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;初始投票给自己&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
集群刚启动时，所有服务器的logicClock都为1，zxid都为0。&lt;/p&gt;

&lt;p&gt;各服务器初始化后，都投票给自己，并将自己的一票存入自己的票箱，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/start_election_1.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/start_election_1.png&quot; alt=&quot;Cluster start election step 1&quot; /&gt;&lt;/a&gt;  &lt;br /&gt;
在上图中，(1, 1, 0)第一位数代表投出该选票的服务器的logicClock，第二位数代表被推荐的服务器的myid，第三位代表被推荐的服务器的最大的zxid。由于该步骤中所有选票都投给自己，所以第二位的myid即是自己的myid，第三位的zxid即是自己的zxid。&lt;/p&gt;

&lt;p&gt;此时各自的票箱中只有自己投给自己的一票。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;更新选票&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
服务器收到外部投票后，进行选票PK，相应更新自己的选票并广播出去，并将合适的选票存入自己的票箱，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/start_election_2.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/start_election_2.png&quot; alt=&quot;Cluster start election step 2&quot; /&gt;&lt;/a&gt;  &lt;br /&gt;
服务器1收到服务器2的选票（1, 2, 0）和服务器3的选票（1, 3, 0）后，由于所有的logicClock都相等，所有的zxid都相等，因此根据myid判断应该将自己的选票按照服务器3的选票更新为（1, 3, 0），并将自己的票箱全部清空，再将服务器3的选票与自己的选票存入自己的票箱，接着将自己更新后的选票广播出去。此时服务器1票箱内的选票为(1, 3)，(3, 3)。&lt;/p&gt;

&lt;p&gt;同理，服务器2收到服务器3的选票后也将自己的选票更新为（1, 3, 0）并存入票箱然后广播。此时服务器2票箱内的选票为(2, 3)，(3, ,3)。&lt;/p&gt;

&lt;p&gt;服务器3根据上述规则，无须更新选票，自身的票箱内选票仍为（3, 3）。&lt;/p&gt;

&lt;p&gt;服务器1与服务器2更新后的选票广播出去后，由于三个服务器最新选票都相同，最后三者的票箱内都包含三张投给服务器3的选票。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;根据选票确定角色&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
根据上述选票，三个服务器一致认为此时服务器3应该是Leader。因此服务器1和2都进入FOLLOWING状态，而服务器3进入LEADING状态。之后Leader发起并维护与Follower间的心跳。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/start_election_3.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/start_election_3.png&quot; alt=&quot;Cluster start election step 3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;follower重启&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#Follower%E9%87%8D%E5%90%AF&quot; title=&quot;Follower重启&quot;&gt;&lt;/a&gt;Follower重启&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Follower重启投票给自己&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
Follower重启，或者发生网络分区后找不到Leader，会进入LOOKING状态并发起新的一轮投票。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/follower_restart_election_1.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/follower_restart_election_1.png&quot; alt=&quot;Follower restart election step 1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;发现已有Leader后成为Follower&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
服务器3收到服务器1的投票后，将自己的状态LEADING以及选票返回给服务器1。服务器2收到服务器1的投票后，将自己的状态FOLLOWING及选票返回给服务器1。此时服务器1知道服务器3是Leader，并且通过服务器2与服务器3的选票可以确定服务器3确实得到了超过半数的选票。因此服务器1进入FOLLOWING状态。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/follower_restart_election_2.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/follower_restart_election_2.png&quot; alt=&quot;Follower restart election step 2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;leader重启&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#Leader%E9%87%8D%E5%90%AF&quot; title=&quot;Leader重启&quot;&gt;&lt;/a&gt;Leader重启&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Follower发起新投票&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
Leader（服务器3）宕机后，Follower（服务器1和2）发现Leader不工作了，因此进入LOOKING状态并发起新的一轮投票，并且都将票投给自己。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_1.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_1.png&quot; alt=&quot;Leader restart election step 1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;广播更新选票&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
服务器1和2根据外部投票确定是否要更新自身的选票。这里有两种情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器1和2的zxid相同。例如在服务器3宕机前服务器1与2完全与之同步。此时选票的更新主要取决于myid的大小&lt;/li&gt;
  &lt;li&gt;服务器1和2的zxid不同。在旧Leader宕机之前，其所主导的写操作，只需过半服务器确认即可，而不需所有服务器确认。换句话说，服务器1和2可能一个与旧Leader同步（即zxid与之相同）另一个不同步（即zxid比之小）。此时选票的更新主要取决于谁的zxid较大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在上图中，服务器1的zxid为11，而服务器2的zxid为10，因此服务器2将自身选票更新为（3, 1, 11），如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_2.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_2.png&quot; alt=&quot;Leader restart election step 2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;选出新Leader&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
经过上一步选票更新后，服务器1与服务器2均将选票投给服务器1，因此服务器2成为Follower，而服务器1成为新的Leader并维护与服务器2的心跳。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_3.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_3.png&quot; alt=&quot;Leader restart election step 3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;旧Leader恢复后发起选举&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
旧的Leader恢复后，进入LOOKING状态并发起新一轮领导选举，并将选票投给自己。此时服务器1会将自己的LEADING状态及选票（3, 1, 11）返回给服务器3，而服务器2将自己的FOLLOWING状态及选票（3, 1, 11）返回给服务器3。如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_4.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_4.png&quot; alt=&quot;Leader restart election step 4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;旧Leader成为Follower&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
服务器3了解到Leader为服务器1，且根据选票了解到服务器1确实得到过半服务器的选票，因此自己进入FOLLOWING状态。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_5.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/leader_restart_election_5.png&quot; alt=&quot;Leader restart election step 5&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;一致性保证&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81&quot; title=&quot;一致性保证&quot;&gt;&lt;/a&gt;一致性保证&lt;/h1&gt;

&lt;p&gt;ZAB协议保证了在Leader选举的过程中，已经被Commit的数据不会丢失，未被Commit的数据对客户端不可见。&lt;/p&gt;

&lt;h2 id=&quot;commit过的数据不丢失&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#Commit%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1&quot; title=&quot;Commit过的数据不丢失&quot;&gt;&lt;/a&gt;Commit过的数据不丢失&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Failover前状态&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
为更好演示Leader Failover过程，本例中共使用5个Zookeeper服务器。A作为Leader，共收到P1、P2、P3三条消息，并且Commit了1和2，且总体顺序为P1、P2、C1、P3、C2。根据顺序性原则，其它Follower收到的消息的顺序肯定与之相同。其中B与A完全同步，C收到P1、P2、C1，D收到P1、P2，E收到P1，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/recovery_1.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/recovery_1.png&quot; alt=&quot;Leader Failover step 1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里要注意&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于A没有C3，意味着收到P3的服务器的总个数不会超过一半，也即包含A在内最多只有两台服务器收到P3。在这里A和B收到P3，其它服务器均未收到P3&lt;/li&gt;
  &lt;li&gt;由于A已写入C1、C2，说明它已经Commit了P1、P2，因此整个集群有超过一半的服务器，即最少三个服务器收到P1、P2。在这里所有服务器都收到了P1，除E外其它服务器也都收到了P2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;选出新Leader&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
旧Leader也即A宕机后，其它服务器根据上述FastLeaderElection算法选出B作为新的Leader。C、D和E成为Follower且以B为Leader后，会主动将自己最大的zxid发送给B，B会将Follower的zxid与自身zxid间的所有被Commit过的消息同步给Follower，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/recovery_2.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/recovery_2.png&quot; alt=&quot;Leader Failover step 2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上图中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;P1和P2都被A Commit，因此B会通过同步保证P1、P2、C1与C2都存在于C、D和E中&lt;/li&gt;
  &lt;li&gt;P3由于未被A Commit，同时幸存的所有服务器中P3未存在于大多数据服务器中，因此它不会被同步到其它Follower&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;通知Follower可对外服务&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
同步完数据后，B会向D、C和E发送NEWLEADER命令并等待大多数服务器的ACK（下图中D和E已返回ACK，加上B自身，已经占集群的大多数），然后向所有服务器广播UPTODATE命令。收到该命令后的服务器即可对外提供服务。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/recovery_3.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/recovery_3.png&quot; alt=&quot;Leader Failover step 3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;未commit过的消息对客户端不可见&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E6%9C%AACommit%E8%BF%87%E7%9A%84%E6%B6%88%E6%81%AF%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8D%E5%8F%AF%E8%A7%81&quot; title=&quot;未Commit过的消息对客户端不可见&quot;&gt;&lt;/a&gt;未Commit过的消息对客户端不可见&lt;/h2&gt;

&lt;p&gt;在上例中，P3未被A Commit过，同时因为没有过半的服务器收到P3，因此B也未Commit P3（如果有过半服务器收到P3，即使A未Commit P3，B会主动Commit P3，即C3），所以它不会将P3广播出去。&lt;/p&gt;

&lt;p&gt;具体做法是，B在成为Leader后，先判断自身未Commit的消息（本例中即P3）是否存在于大多数服务器中从而决定是否要将其Commit。然后B可得出自身所包含的被Commit过的消息中的最小zxid（记为min_zxid）与最大zxid（记为max_zxid）。C、D和E向B发送自身Commit过的最大消息zxid（记为max_zxid）以及未被Commit过的所有消息（记为zxid_set）。B根据这些信息作出如下操作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果Follower的max_zxid与Leader的max_zxid相等，说明该Follower与Leader完全同步，无须同步任何数据&lt;/li&gt;
  &lt;li&gt;如果Follower的max_zxid在Leader的(min_zxid，max_zxid)范围内，Leader会通过TRUNC命令通知Follower将其zxid_set中大于Follower的max_zxid（如果有）的所有消息全部删除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述操作保证了未被Commit过的消息不会被Commit从而对外不可见。&lt;/p&gt;

&lt;p&gt;上述例子中Follower上并不存在未被Commit的消息。但可考虑这种情况，如果将上述例子中的服务器数量从五增加到七，服务器F包含P1、P2、C1、P3，服务器G包含P1、P2。此时服务器F、A和B都包含P3，但是因为票数未过半，因此B作为Leader不会Commit P3，而会通过TRUNC命令通知F删除P3。如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/recovery_4.png&quot;&gt;&lt;img src=&quot;http://www.jasongj.com/img/zookeeper/1_architecture/recovery_4.png&quot; alt=&quot;Leader Failover step 4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;http://www.jasongj.com/zookeeper/fastleaderelection/#%E6%80%BB%E7%BB%93&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;由于使用主从复制模式，所有的写操作都要由Leader主导完成，而读操作可通过任意节点完成，因此Zookeeper读性能远好于写性能，更适合读多写少的场景&lt;/li&gt;
  &lt;li&gt;虽然使用主从复制模式，同一时间只有一个Leader，但是Failover机制保证了集群不存在单点失败（SPOF）的问题&lt;/li&gt;
  &lt;li&gt;ZAB协议保证了Failover过程中的数据一致性&lt;/li&gt;
  &lt;li&gt;服务器收到数据后先写本地文件再进行处理，保证了数据的持久性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://cdn.jasongj.com/img/WeChat_QR.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Nov 2018 19:15:06 +0800</pubDate>
        <link>http://localhost:4000/2018/11/19/zookeeper-l-3/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/19/zookeeper-l-3/</guid>
        
        <category>机器学习</category>
        
        <category>自动化部署</category>
        
        
      </item>
    
      <item>
        <title>Zookeeper工作原理</title>
        <description>&lt;h1 id=&quot;apache-zookeeper的znode数据限制大小是多少&quot;&gt;Apache ZooKeeper的zNode数据限制大小是多少？&lt;/h1&gt;

&lt;p&gt;1GB？10MB？1KB？&lt;/p&gt;

&lt;p&gt;zNode Limit = 1MB。&lt;/p&gt;

&lt;p&gt;这是ZooKeeper中单个zNode或键/值对的默认大小。应该注意的是，密钥和值都被合并到这个等式中。ZooKeeper被设计为用于小键的高读取，高吞吐量系统。它不是设计为容纳非常大的数据值的大型数据存储。因此，此1MB值是默认配置选项，可以覆盖。建议不要这样做 - 但是增加一点尺寸可能不会损坏您的系统（这完全取决于您的独特访问模式，这些更改应谨慎进行，风险自负）。&lt;/p&gt;

&lt;h2 id=&quot;估算zk默认1mb可存储多少数据&quot;&gt;估算ZK默认1MB可存储多少数据&lt;/h2&gt;

&lt;p&gt;1M=1024k=1048576字节
算法是： 
8bit(位)=1Byte(字节) 
1024Byte(字节)=1KB 
1024KB=1MB 
1024MB=1GB 
1024GB=1TB 
一个汉字要占用2个字节 
一个汉字要占用1个字节&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
-- 存储中文
1MB =1024KB = 1024*1024Byte =1024*1024*8/4=524,288个汉字

-- 存储英文
1MB =1024KB = 1024*1024Byte =1024*1024*8/1=1,048,576个汉字

Notes

(utf-8)

1个中文=3~4字节
1个中文标点=3字节
1个英文字母= 1字节
1个英文标点= 1字节


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://hev.cc/257.html&quot;&gt;UTF-8 编码里，一个汉字占用多少个字节？&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;存储json&quot;&gt;存储json&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{&quot;bizType&quot;:&quot;dragDown&quot;,&quot;skinId&quot;:&quot;skin_392&quot;,&quot;startTime&quot;:&quot;2018-11-27 04:00:00&quot;,&quot;endTime&quot;:&quot;2019-11-30 00:00:05&quot;,&quot;on&quot;:0}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这串json，占用115字节，存储1000个json传占用多少内存？&lt;/p&gt;

&lt;p&gt;115&lt;em&gt;1000&lt;/em&gt;8 = 920,000 =~ 1MB&lt;/p&gt;

&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;

&lt;p&gt;一些时候你会被要求做出保守估计。比如，你可能需要估计从磁盘中生成 100 张图片的缩略图需要的时间或者一个数据结构需要多少的内存。&lt;strong&gt;2 的次方表&lt;/strong&gt;和&lt;strong&gt;每个开发者都需要知道的一些时间数据&lt;/strong&gt;（译注：OSChina 上有这篇文章的&lt;a href=&quot;https://www.oschina.net/news/30009/every-programmer-should-know&quot;&gt;译文&lt;/a&gt;）都是一些很方便的参考资料。&lt;/p&gt;

&lt;h3 id=&quot;2-的次方表&quot;&gt;2 的次方表&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;来源及延伸阅读&quot;&gt;来源及延伸阅读&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Power_of_two&quot;&gt;2 的次方&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;每个程序员都应该知道的延迟数&quot;&gt;每个程序员都应该知道的延迟数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                          100   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA-&amp;gt;Netherlands-&amp;gt;CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基于上述数字的指标：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从磁盘以 30 MB/s 的速度顺序读取&lt;/li&gt;
  &lt;li&gt;以 100 MB/s 从 1 Gbps 的以太网顺序读取&lt;/li&gt;
  &lt;li&gt;从 SSD 以 1 GB/s 的速度读取&lt;/li&gt;
  &lt;li&gt;以 4 GB/s 的速度从主存读取&lt;/li&gt;
  &lt;li&gt;每秒能绕地球 6-7 圈&lt;/li&gt;
  &lt;li&gt;数据中心内每秒有 2,000 次往返&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;L1 cache ：………………………………………………..0.5ns
branch mispredict(转移、分支预测) : ……………..5ns
L2 cache :………………………………………………… 7ns
互斥锁\解锁 :…………………………………………….. 25ns
1k字节压缩(Zippy) : …………………………………….3000ns = 3us
在1Gbps的网络上发送2k字节 : ……………………….20,000ns = 20us
SSD随机读 ：……………………………………………..150,000ns = 150us
从内存顺序读取1MB ：…………………………………250,000ns = 250 us
同一个数据中心往返 ：………………………………….500,000ns = 0.5ms
从SSD顺序读取1MB ： …………………………………1,000,000ns = 1ms
磁盘搜索:…………………………………………………..10,000,000ns = 10ms
从磁盘里面读出1MB : …………………………………..20，000，000ns = 20ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;延迟数可视化&quot;&gt;延迟数可视化&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;来源及延伸阅读-1&quot;&gt;来源及延伸阅读&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;每个程序员都应该知道的延迟数 — 1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/hellerbarde/2843375&quot;&gt;每个程序员都应该知道的延迟数 — 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf&quot;&gt;关于建设大型分布式系统的的设计方案、课程和建议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf&quot;&gt;关于建设大型可拓展分布式系统的软件工程咨询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 19 Oct 2018 19:15:06 +0800</pubDate>
        <link>http://localhost:4000/2018/10/19/zookeeper-l-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/19/zookeeper-l-2/</guid>
        
        <category>机器学习</category>
        
        <category>自动化部署</category>
        
        
      </item>
    
      <item>
        <title>Zookeeper工作原理</title>
        <description>&lt;h1 id=&quot;zookeeper工作原理&quot;&gt;Zookeeper工作原理&lt;/h1&gt;

&lt;p&gt;http://gotowqj.iteye.com/blog/2065572&lt;/p&gt;

&lt;p&gt;转发自: http://cailin.iteye.com/blog/2014486&lt;/p&gt;

&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。&lt;/p&gt;

&lt;h1 id=&quot;1-zookeeper的基本概念&quot;&gt;1 Zookeeper的基本概念&lt;/h1&gt;

&lt;h2 id=&quot;11-角色&quot;&gt;1.1 角色&lt;/h2&gt;

&lt;p&gt;Zookeeper中的角色主要有以下三类，如下表所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://static.oschina.net/uploads/img/201308/08171344_cqXs.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201308/08171344_cqXs.jpg&quot; alt=&quot;&quot; title=&quot;7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;系统模型如图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://static.oschina.net/uploads/img/201308/08171345_l5K3.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201308/08171345_l5K3.jpg&quot; alt=&quot;&quot; title=&quot;1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-设计目的&quot;&gt;1.2 设计目的&lt;/h2&gt;

&lt;p&gt;1.最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。&lt;/p&gt;

&lt;p&gt;2 .可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。&lt;/p&gt;

&lt;p&gt;3 .实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。&lt;/p&gt;

&lt;p&gt;4 .等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。&lt;/p&gt;

&lt;p&gt;5.原子性：更新只能成功或者失败，没有中间状态。&lt;/p&gt;

&lt;p&gt;6 .顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。&lt;/p&gt;

&lt;h1 id=&quot;2-zookeeper的工作原理&quot;&gt;2 ZooKeeper的工作原理&lt;/h1&gt;

&lt;p&gt;Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。&lt;/p&gt;

&lt;p&gt;为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。&lt;/p&gt;

&lt;p&gt;每个Server在工作过程中有三种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LOOKING：当前Server不知道leader是谁，正在搜寻&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LEADING：当前Server即为选举出来的leader&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FOLLOWING：leader已经选举出来，当前Server与之同步&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;21-选主流程&quot;&gt;2.1 选主流程&lt;/h2&gt;

&lt;p&gt;当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;1 .选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2 .选举线程首先向所有Server发起一次询问(包括自己)；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3 .选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.&lt;/p&gt;

&lt;p&gt;每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://static.oschina.net/uploads/img/201308/08171345_J3LF.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201308/08171345_J3LF.jpg&quot; alt=&quot;&quot; title=&quot;2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://static.oschina.net/uploads/img/201308/08171346_zLlp.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201308/08171346_zLlp.jpg&quot; alt=&quot;&quot; title=&quot;3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-同步流程&quot;&gt;2.2 同步流程&lt;/h2&gt;

&lt;p&gt;选完leader以后，zk就进入状态同步过程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;leader等待server连接；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2 .Follower连接leader，将最大的zxid发送给leader；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3 .Leader根据follower的zxid确定同步点；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4 .完成同步后通知follower 已经成为uptodate状态；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;5 .Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;流程图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://static.oschina.net/uploads/img/201308/08171346_oExa.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201308/08171346_oExa.jpg&quot; alt=&quot;&quot; title=&quot;4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;23-工作流程&quot;&gt;2.3 工作流程&lt;/h2&gt;

&lt;h3 id=&quot;231-leader工作流程&quot;&gt;2.3.1 Leader工作流程&lt;/h3&gt;

&lt;p&gt;Leader主要有三个功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;1 .恢复数据；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2 .维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3 .Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。&lt;br /&gt;
Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。&lt;a href=&quot;http://static.oschina.net/uploads/img/201308/08171346_87iA.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201308/08171346_87iA.jpg&quot; alt=&quot;&quot; title=&quot;5&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;232-follower工作流程&quot;&gt;2.3.2 Follower工作流程&lt;/h3&gt;

&lt;p&gt;Follower主要有四个功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2 .接收Leader消息并进行处理；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3 .接收Client的请求，如果为写请求，发送给Leader进行投票；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;4 .返回Client结果。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Follower的消息循环处理如下几种来自Leader的消息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;1 .PING消息： 心跳消息；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2 .PROPOSAL消息：Leader发起的提案，要求Follower投票；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3 .COMMIT消息：服务器端最新一次提案的信息；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4 .UPTODATE消息：表明同步完成；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;5 .REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;6 .SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://static.oschina.net/uploads/img/201308/08171346_slOJ.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201308/08171346_slOJ.jpg&quot; alt=&quot;&quot; title=&quot;6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。&lt;/p&gt;

&lt;p&gt;主流应用场景：&lt;/p&gt;

&lt;p&gt;Zookeeper的主流应用场景实现思路（除去官方示例）   &lt;br /&gt;
(1)配置管理  集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。  &lt;br /&gt;
Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));  &lt;br /&gt;
以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。     &lt;a href=&quot;http://static.oschina.net/uploads/img/201312/20143856_Yv5J.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201312/20143856_Yv5J.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
(2)集群管理   应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。  &lt;br /&gt;
Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。  &lt;br /&gt;
另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号  &lt;br /&gt;
我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。  &lt;a href=&quot;http://static.oschina.net/uploads/img/201312/20143856_6ZXG.jpg&quot;&gt;&lt;img src=&quot;http://static.oschina.net/uploads/img/201312/20143856_6ZXG.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;zookeeper-监视watches-简介&quot;&gt;Zookeeper 监视（Watches） 简介&lt;/h3&gt;

&lt;p&gt;Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。&lt;/p&gt;

&lt;p&gt;Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;（一次性触发）One-time trigger&lt;/p&gt;

    &lt;p&gt;当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（发送至客户端）Sent to the client&lt;/p&gt;

    &lt;p&gt;Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（被设置 watch 的数据）The data for which the watch was set&lt;/p&gt;

    &lt;p&gt;这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。&lt;/p&gt;

&lt;h3 id=&quot;zookeeper-c-api-常量与部分结构struct介绍&quot;&gt;Zookeeper C API 常量与部分结构(struct)介绍&lt;/h3&gt;

&lt;h4 id=&quot;与-acl-相关的结构与常量&quot;&gt;与 ACL 相关的结构与常量：&lt;/h4&gt;

&lt;p&gt;struct Id 结构为：&lt;/p&gt;

&lt;pre&gt;
struct Id {     char * scheme;     char * id; };
&lt;/pre&gt;

&lt;p&gt;struct ACL 结构为：&lt;/p&gt;

&lt;pre&gt;
struct ACL {     int32_t perms;     struct Id id; };
&lt;/pre&gt;

&lt;p&gt;struct ACL_vector 结构为：&lt;/p&gt;

&lt;pre&gt;
struct ACL_vector {     int32_t count;     struct ACL *data; };
&lt;/pre&gt;

&lt;p&gt;与 znode 访问权限有关的常量&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;const int ZOO_PERM_DELETE;//允许客户端删除子节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;与 ACL IDs 相关的常量&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;struct Id ZOO_AUTH_IDS;// (‘auth’,’’)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三种标准的 ACL&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;与-interest-相关的常量zookeeper_write-zookeeper_read&quot;&gt;与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ&lt;/h4&gt;

&lt;p&gt;这 两个常量用于标识感兴趣的事件并通知 zookeeper 发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。&lt;/p&gt;

&lt;h4 id=&quot;与节点创建相关的常量zoo_ephemeral-zoo_sequence&quot;&gt;与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE&lt;/h4&gt;

&lt;p&gt;zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。&lt;/p&gt;

&lt;h4 id=&quot;与连接状态-stat-相关的常量&quot;&gt;与连接状态 Stat 相关的常量&lt;/h4&gt;

&lt;p&gt;以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;col 1&lt;/th&gt;
      &lt;th&gt;col 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ZOOAPI const int&lt;/td&gt;
      &lt;td&gt;ZOO_EXPIRED_SESSION_STATE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZOOAPI const int&lt;/td&gt;
      &lt;td&gt;ZOO_AUTH_FAILED_STATE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZOOAPI const int&lt;/td&gt;
      &lt;td&gt;ZOO_CONNECTING_STATE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZOOAPI const int&lt;/td&gt;
      &lt;td&gt;ZOO_ASSOCIATING_STATE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZOOAPI const int&lt;/td&gt;
      &lt;td&gt;ZOO_CONNECTED_STATE&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;与监视类型watch-types相关的常量&quot;&gt;与监视类型(Watch Types)相关的常量&lt;/h4&gt;

&lt;p&gt;以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZOO_SESSION_EVENT; // 会话丢失&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZOO_NOTWATCHING_EVENT; // 监视被移除。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;zookeeper-c-api-错误码介绍-zoo_errors&quot;&gt;Zookeeper C API 错误码介绍 ZOO_ERRORS&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;col 1&lt;/th&gt;
      &lt;th&gt;col 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ZOK&lt;/td&gt;
      &lt;td&gt;正常返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZSYSTEMERROR&lt;/td&gt;
      &lt;td&gt;系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZRUNTIMEINCONSISTENCY&lt;/td&gt;
      &lt;td&gt;运行时非一致性错误。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZDATAINCONSISTENCY&lt;/td&gt;
      &lt;td&gt;数据非一致性错误。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZCONNECTIONLOSS&lt;/td&gt;
      &lt;td&gt;Zookeeper 客户端与服务器端失去连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZMARSHALLINGERROR&lt;/td&gt;
      &lt;td&gt;在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZUNIMPLEMENTED&lt;/td&gt;
      &lt;td&gt;该操作未实现(Operation is unimplemented)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZOPERATIONTIMEOUT&lt;/td&gt;
      &lt;td&gt;该操作超时(Operation timeout)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZBADARGUMENTS&lt;/td&gt;
      &lt;td&gt;非法参数错误(Invalid arguments)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZINVALIDSTATE&lt;/td&gt;
      &lt;td&gt;非法句柄状态(Invliad zhandle state)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZAPIERROR&lt;/td&gt;
      &lt;td&gt;API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZNONODE&lt;/td&gt;
      &lt;td&gt;节点不存在(Node does not exist)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZNOAUTH&lt;/td&gt;
      &lt;td&gt;没有经过授权(Not authenticated)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZBADVERSION&lt;/td&gt;
      &lt;td&gt;版本冲突(Version conflict)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZNOCHILDRENFOREPHEMERALS&lt;/td&gt;
      &lt;td&gt;临时节点不能拥有子节点(Ephemeral nodes may not have children)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZNODEEXISTS&lt;/td&gt;
      &lt;td&gt;节点已经存在(The node already exists)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZNOTEMPTY&lt;/td&gt;
      &lt;td&gt;该节点具有自身的子节点(The node has children)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZSESSIONEXPIRED&lt;/td&gt;
      &lt;td&gt;会话过期(The session has been expired by the server)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZINVALIDCALLBACK&lt;/td&gt;
      &lt;td&gt;非法的回调函数(Invalid callback specified)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZINVALIDACL&lt;/td&gt;
      &lt;td&gt;非法的ACL(Invalid ACL specified)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZAUTHFAILED&lt;/td&gt;
      &lt;td&gt;客户端授权失败(Client authentication failed)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZCLOSING&lt;/td&gt;
      &lt;td&gt;Zookeeper 连接关闭(ZooKeeper is closing)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZNOTHING&lt;/td&gt;
      &lt;td&gt;并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ZSESSIONMOVED&lt;/td&gt;
      &lt;td&gt;会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;watch事件类型&quot;&gt;Watch事件类型：&lt;/h5&gt;

&lt;p&gt;ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置&lt;br /&gt;
ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置&lt;br /&gt;
ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置&lt;br /&gt;
ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置&lt;br /&gt;
ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发&lt;br /&gt;
ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Oct 2018 18:15:06 +0800</pubDate>
        <link>http://localhost:4000/2018/10/01/zookeeper-l-1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/01/zookeeper-l-1/</guid>
        
        <category>机器学习</category>
        
        <category>自动化部署</category>
        
        
      </item>
    
      <item>
        <title>Spring中的XML解析机制</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;今天先写spring的IOC。IOC的概念控制反转，我的体会是spring通过xml的配置，把一些属性的实例化本来是由我们自己程序做的事情交给了spring的IOC容器。不过这是最简单的，spring还帮我们做了其他很多的工作。不过我认为IOC最核心的工作也就是这个了。&lt;/p&gt;

&lt;p&gt;开始我读spring的源代码是根据下载的spring技术内幕pdf资料。由于我下载的是spring3.0的，而这个pdf是2.0的。然后又懵懵懂懂的读下去，遇到不懂的就看源代码和调试。这样下来几天了还没有什么进展。后面我想了一下，觉得不应该这样研究。应该是找到目标，然后再有目的性的研究。这样下来，效率高多了。虽然我以前研究也都是根据问题然后有目的性的研究，但是这些都没有很好的规范。所以执行起来还是比较乱。&lt;/p&gt;

&lt;p&gt;今天先从以下两个角度细分&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Spring怎么读取xml配置文件的&lt;/li&gt;
  &lt;li&gt;Spring怎么设置其属性的&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;spring如何读取xml配置&quot;&gt;Spring如何读取xml配置&lt;/h2&gt;

&lt;p&gt;读取配置文件的入口是 &lt;code class=&quot;highlighter-rouge&quot;&gt;java XmlBeanDefinitionReader&lt;/code&gt; 这个类。其中有一个这样的方法&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;springframework&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;beans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;xml&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;XmlBeanDefinitionReader&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractBeanDefinitionReader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * Actually load bean definitions from the specified XML file.
 * @param inputSource the SAX InputSource to read from
 * @param resource the resource descriptor for the XML file
 * @return the number of bean definitions found
 * @throws BeanDefinitionStoreException in case of loading or parsing errors
 * @see #doLoadDocument
 * @see #registerBeanDefinitions
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doLoadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InputSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeanDefinitionStoreException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Document&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doLoadDocument&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registerBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BeanDefinitionStoreException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SAXParseException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;XmlBeanDefinitionStoreException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDescription&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt;
				&lt;span class=&quot;s&quot;&gt;&quot;Line &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLineNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; in XML document from &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; is invalid&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SAXException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;XmlBeanDefinitionStoreException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDescription&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt;
				&lt;span class=&quot;s&quot;&gt;&quot;XML document from &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; is invalid&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ParserConfigurationException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BeanDefinitionStoreException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDescription&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt;
				&lt;span class=&quot;s&quot;&gt;&quot;Parser configuration exception parsing XML from &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BeanDefinitionStoreException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDescription&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt;
				&lt;span class=&quot;s&quot;&gt;&quot;IOException parsing XML document from &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BeanDefinitionStoreException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDescription&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt;
				&lt;span class=&quot;s&quot;&gt;&quot;Unexpected exception parsing XML document from &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 05 Sep 2018 21:45:45 +0800</pubDate>
        <link>http://localhost:4000/2018/09/05/spring-parse-xml/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/05/spring-parse-xml/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>Spring中的XML schema扩展机制</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;很久没有写关于 Spring 的文章了，最近在系统梳理 Dubbo 代码的过程中发现了 XML schema 这个被遗漏的知识点。由于工作中使用 SpringBoot 比较多的原因，几乎很少接触 XML，此文可以算做是亡羊补牢，另一方面，也为后续的 Dubbo 源码解析做个铺垫。。&lt;/p&gt;

&lt;p&gt;XML schema 扩展机制是啥？这并不是一块很大的知识点，翻阅一下 Spring 的文档，我甚至没找到一个贯穿上下文的词来描述这个功能，XML Schema Authoring 是文档中对应的标题，简单来说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spring 为基于 XML 构建的应用提供了一种扩展机制，用于定义和配置 Bean。 它允许使用者编写自定义的 XML bean 解析器，并将解析器本身以及最终定义的 Bean 集成到 Spring IOC 容器中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:dubbo=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
    &quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- current application configuration --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dubbo:application&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;demo-provider&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- registry center configuration --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dubbo:registry&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;address=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;N/A&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- service configuration --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dubbo:service&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;service&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;interface=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.alibaba.dubbo.config.spring.api.DemoServiceSon&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;demoService&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;demoService&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.alibaba.dubbo.config.spring.impl.DemoServiceSonImpl&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dubbo 依赖了 Spring，并提供了一套自定义的 XML 标签，&lt;dubbo:application&gt; ,&lt;dubbo:registry&gt; ,&lt;dubbo:protocol&gt;,&lt;dubbo:service&gt;。作为使用者，大多数人只需要关心这些参数如何配置，但不知道有没有人好奇过，它们是如何加载进入 Spring 的 IOC 容器中被其他组件使用的呢？这便牵扯出了今天的主题：Spring 对 XML schema 的扩展支持。&lt;/dubbo:service&gt;&lt;/dubbo:protocol&gt;&lt;/dubbo:registry&gt;&lt;/dubbo:application&gt;&lt;/p&gt;

&lt;h2 id=&quot;自定义-xml-扩展&quot;&gt;自定义 XML 扩展&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;完成XML自定义扩展，需要下面几个步骤:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1329440-740c239f41566b16.png&quot; alt=&quot;XML自定义扩展步骤&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个 XML Schema 文件，描述自定义的合法构建模块，也就是xsd文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义个处理器类，并实现NamespaceHandler接口(比较容易)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义一个或多个解析器，实现BeanDefinitionParser接口(最关键的部分)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注册上面的组件到Spring IOC容器中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们的目的便是想要实现一个 myns XML schema，我们的项目中可以自定义 demo.xml，在其中会以 myns 为标签来定义不同的类，并在最终的测试代码中验证这些声明在 demo.xml 的类是否被 Spring 成功加载。大概像这样，是不是和 dubbo.xml 的格式很像呢？&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:myns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://code.xxx.com/schema/myns&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
    http://code.xxx.com/schema/myns http://code.xxx.com/schema/myns.xsd
    &quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;myns:dateformat&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testDateFormat&quot;&lt;/span&gt;
                 &lt;span class=&quot;na&quot;&gt;pattern=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yyyy-MM-dd HH:mm&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;动手实现&quot;&gt;动手实现&lt;/h2&gt;

&lt;p&gt;有了明确的目标，我们逐步开展自己的工作。&lt;/p&gt;

&lt;h2 id=&quot;编写myxsd&quot;&gt;编写my.xsd&lt;/h2&gt;

&lt;p&gt;resources/META-INF/my.xsd&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xsd&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;xsd:schema xmlns=&quot;http://code.xxx.com/schema/myns&quot;
            xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
            xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot;
            targetNamespace=&quot;http://code.xxx.com/schema/myns&quot;
            elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&amp;gt;
    &amp;lt;xsd:import namespace=&quot;http://www.springframework.org/schema/beans&quot;/&amp;gt;
    &amp;lt;!--
        用法:
        &amp;lt;myns:dateformat id=&quot;dateFormat&quot; pattern=&quot;yyyy-MM-dd HH:mm&quot; /&amp;gt;
        或
        &amp;lt;bean id=&quot;dateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&amp;gt;
            &amp;lt;constructor-arg value=&quot;yyyy-HH-dd HH:mm&quot;/&amp;gt;
        &amp;lt;/bean&amp;gt;
    --&amp;gt;
    &amp;lt;xsd:element name=&quot;dateformat&quot;&amp;gt;
        &amp;lt;xsd:complexType&amp;gt;
            &amp;lt;xsd:complexContent&amp;gt;
                &amp;lt;xsd:extension base=&quot;beans:identifiedType&quot;&amp;gt;
                    &amp;lt;xsd:attribute name=&quot;pattern&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&amp;gt;
                &amp;lt;/xsd:extension&amp;gt;
            &amp;lt;/xsd:complexContent&amp;gt;
        &amp;lt;/xsd:complexType&amp;gt;
    &amp;lt;/xsd:element&amp;gt;

&amp;lt;/xsd:schema&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;① 注意这里的 targetNamespace=”http://code.xxx.com/schema/myns” 这便是之后 myns 标签的关键点。
② my.xsd 定义了元素： dateformat，出于简单考虑，都只有一个 pattern 字段。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;schema 的意义在于它可以和 eclipse/IDEA 这样智能化的集成开发环境形成很好的搭配，在编辑 XML 的过程中，用户可以获得告警和提示。 如果配置得当，可以使用自动完成功能让用户在事先定义好的枚举类型中进行选择。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2 编写DateformatNamespaceHandler&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.beans.factory.xml.NamespaceHandlerSupport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DateformatNamespaceHandler&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NamespaceHandlerSupport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dateformat&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeteformatDefinitionParser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成 schema 之后，还需要一个 NamespaceHandler 来帮助 Spring 解析 XML 中不同命名空间的各类元素。&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;myns:dateformat&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testDateFormat&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pattern=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yyyy-MM-dd HH:mm&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不同的命名空间需要不同的 NamespaceHandler 来处理，在今天的示例中，我们使用 DateformatNamespaceHandler 来解析 myns 命名空间。DateformatNamespaceHandler 继承自 NamespaceHandlerSupport 类，并在其 init() 方法中注册了两个 BeanDefinitionParser ，用于解析 myns 命名空间/myns.xsd 约束中定义的元素：dateformat。BeanDefinitionParser 是下一步的主角，我们暂且跳过，将重心放在父类 NamespaceHandlerSupport 之上。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NamespaceHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;nc&quot;&gt;BeanDefinition&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ParserContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parserContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;nc&quot;&gt;BeanDefinitionHolder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decorate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeanDefinitionHolder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;definition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ParserContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parserContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NamespaceHandlerSupport 是 NamespaceHandler 命名空间处理器的抽象实现，我粗略看了NamespaceHandler 的几个实现类，parse 和 decorate 方法可以完成元素节点的组装并通过 ParserContext 注册到 Ioc 容器中，但实际我们并没有调用这两个方法，而是通过 init() 方法注册 BeanDefinitionParser 来完成解析节点以及注册 Bean 的工作，所以对于 NamespaceHandler，我们主要关心 init 中注册的两个 BeanDefinitionParser 即可。&lt;/p&gt;

&lt;p&gt;3 编写DeteformatDefinitionParser
在文章开始我们便标记到 BeanDefinitionParser 是最为关键的一环，每一个 BeanDefinitionParser 实现类都负责一个映射，将一个 XML 节点解析成 IOC 容器中的一个实体类。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.beans.factory.support.BeanDefinitionBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.w3c.dom.Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.text.SimpleDateFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * 解析定义的标签
 * &amp;lt;myns:dateformat id=&quot;dateFormat&quot; pattern=&quot;yyyy-MM-dd HH:mm&quot; /&amp;gt;
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeteformatDefinitionParser&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractSingleBeanDefinitionParser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getBeanClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doParse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeanDefinitionBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanDefinitionBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//解析pattern配置项&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pattern&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;beanDefinitionBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addConstructorArgValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于我们的实体类是非常简单的，所以不存在很复杂的解析代码，而实际项目中，往往需要大量的解析步骤。parse 方法会解析一个个 XML 中的元素，使用 RootBeanDefinition 组装成对象，并最终通过 parserContext 注册到 IOC 容器中。&lt;/p&gt;

&lt;p&gt;至此，我们便完成了 XML 文件中定义的对象到 IOC 容器的映射。&lt;/p&gt;

&lt;h3 id=&quot;4-注册schema和handler&quot;&gt;4 注册schema和handler&lt;/h3&gt;

&lt;p&gt;最后一步还需要通知 Spring，告知其自定义 schema 的所在之处以及对应的处理器。&lt;/p&gt;

&lt;p&gt;resources/META-INF/spring.handlers&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http&lt;span class=&quot;se&quot;&gt;\:&lt;/span&gt;//code.xxx.com/schema/myns&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;com.xxx.app.server.spi.config.schema.DateformatNamespaceHandler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;resources/META-INF/spring.schemas&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http&lt;span class=&quot;se&quot;&gt;\:&lt;/span&gt;//code.xxx.com/schema/myns.xsd&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;META-INF/my.xsd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;没有太多可以说的，需要遵守 Spring 的约定。&lt;/p&gt;

&lt;p&gt;至此一个自定义的 XML schema 便扩展完成了，随后来验证一下。&lt;/p&gt;

&lt;h2 id=&quot;验证扩展&quot;&gt;验证扩展&lt;/h2&gt;

&lt;p&gt;我们首先定义好 demo.xml&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:myns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://code.xxx.com/schema/myns&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
    http://code.xxx.com/schema/myns http://code.xxx.com/schema/myns.xsd
    &quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;myns:dateformat&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testDateFormat&quot;&lt;/span&gt;
                 &lt;span class=&quot;na&quot;&gt;pattern=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yyyy-MM-dd HH:mm&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用 Spring 去加载它，并验证 IOC 容器中是否存在注册成功的 Bean。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConfigTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;


    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testSpringDateFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConfigTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getPackage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/demo.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dateFormat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testDateFormat&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;assertNotNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dateFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;2010-10-10 11:12:14&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ymdhms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ymdhms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dateFormatStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dateFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2010-10-10 11:12&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dateFormatStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ParseException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//执行解析发生异常&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;观察控制台的输出：&lt;/p&gt;

&lt;p&gt;2010-10-10 11:12&lt;/p&gt;

&lt;p&gt;一个基础的基于 XML schema 的扩展便完成了。&lt;/p&gt;

&lt;h3 id=&quot;dubbo中的xml-schema扩展&quot;&gt;Dubbo中的XML schema扩展&lt;/h3&gt;

&lt;p&gt;最后我们以 Dubbo 为例，看看一个成熟的 XML schema 扩展是如何被应用的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://kirito.iocoder.cn/image-20180903190429383.png&quot; alt=&quot;Dubbo中的应用&quot; /&gt;&lt;/p&gt;

&lt;p&gt;刚好对应了四个标准的扩展步骤，是不是对 XML 配置下的 Dubbo 应用有了更好的理解了呢？&lt;/p&gt;

&lt;p&gt;顺带一提，仅仅完成 Bean 的注册还是不够的，在“注册”的同时，Dubbo 还进行了一系列其他操作如：暴露端口，开启服务器，完成注册中心的注册，生成代理对象等等行为，由于不在本文的范围内，后续的 Dubbo 专题会专门介绍这些细节，本文便是了解 Dubbo 加载流程的前置文章了。&lt;/p&gt;

</description>
        <pubDate>Mon, 03 Sep 2018 21:45:45 +0800</pubDate>
        <link>http://localhost:4000/2018/09/03/spring-xsd/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/03/spring-xsd/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
  </channel>
</rss>
